{"meta":{"title":"Davis' Blog","subtitle":"专注于Golang、Node.js技术","description":"欢迎来到没事放放牛的个人博客！","author":"没事放放牛","url":"https://pengfeidai.github.io"},"pages":[{"title":"","date":"2020-06-12T04:35:54.001Z","updated":"2020-05-22T12:29:23.000Z","comments":true,"path":"404.html","permalink":"https://pengfeidai.github.io/404.html","excerpt":"","text":"没事放放牛—msffn.com | 404 html, body { height: 100%; min-height: 100%; background: #161B20; overflow: hidden } #block { width: 1px; height: 1px; font-size: 10px } #block:after { content: ''; position: absolute; top: 36%; left: 50%; width: 1em; height: 1em; -webkit-transform: translateX(-14em); transform: translateX(-14em) } @media screen and (max-width:320px) { #block:after { -webkit-transform: translateX(-11.5em) scale(.8); transform: translateX(-11.5em) scale(.8) } } .home { position: absolute; bottom: 10%; left: 50%; margin-left: -14px; text-decoration: none } .icon-home { position: relative; display: block; width: 30px; height: 30px; background: #484C4D } .icon-home:before { content: ''; position: absolute; width: 0; height: 0; top: -40px; left: -9px; border: 24px solid transparent; border-bottom-color: #484C4D } .icon-home:after { content: ''; position: absolute; height: 0; width: 0; top: 16px; left: 7px; width: 16px; height: 14px; background: #161B20 } !function() { function n() { return \"#\" + (\"00000\" + (16777215 * Math.random() + .5 >> 0).toString(16)).slice( - 6) } function e(e, t) { return e + \"em \" + t + \"em \" + n() } function t(n, e, t, u) { var r = document.getElementById(n); r || (r = document.createElement(\"style\"), r.id = n), r.innerHTML = e + \"{\" + t + \":\" + u + \";}\", document.getElementsByTagName(\"head\")[0].appendChild(r) } function u(n, t, u, r) { for (var o = [], s = 0, h = t - .5; n + u >= s; s++, h = t - .5 * (s + 1)) if (s === n) for (var i = h + .5; t + r >= i; i++) o.push(e(i, n)); else o.push(e(t, s)), n > s && o.push(e(h, s + .5)); return o.join(\",\") } function r(n, t, u) { for (var r = [], o = 0, s = 0; u > s; s++) r.push(e(n + s, 0)), r.push(e(n + s, t)); for (r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), o = t - 1, r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), s = 1; t > s; s++) r.push(e(n - 1, s)), r.push(e(n + u, s)); return r.join(\",\") } setInterval(function() { t(\"style\", \"#block:after\", \"box-shadow\", u(10, 5, 2, 1) + \",\" + r(12, 12, 5) + \",\" + u(10, 26, 2, 1)) }, 200) } ();"},{"title":"关于我","date":"2017-07-07T13:19:11.000Z","updated":"2020-05-22T12:53:56.000Z","comments":true,"path":"about/index.html","permalink":"https://pengfeidai.github.io/about/index.html","excerpt":"","text":"个人简介 姓名： 戴鹏飞 学校： 长江大学 专业： 软件工程 QQ： 302804389(开始聊天) 邮箱： 302804389@qq.com GitHub： https://github.com/pengfeidai 个人简介： 👉目前专注于Golang、Nodejs的程序猿一枚(^ ω ^) ! ! ! 技术清单： Golang、Node.js 、Myslq、MongoDB、Redis、分布式、容器等"},{"title":"我的作品","date":"2020-06-12T04:35:54.084Z","updated":"2020-05-23T15:45:15.000Z","comments":false,"path":"categories/index.html","permalink":"https://pengfeidai.github.io/categories/index.html","excerpt":"","text":"@timeline{ 详情索引@item{ 2020.04Gin-app-start基于 Gin 封装的开发框架，包含了一些常用中间件、方法以及对数据库的操作，功能强大，使用简单。（持续） } @item{ 2020.05用户中心基于gin-app-start完成的同一的应用层用户中心后端服务，包含用户登录、会话校验、角色分配、权限管理等功能。（持续） } @item{ 2017.07移动端音乐 App基于 Vue 全家桶 (2.x) 制作的移动端音乐 WebApp。 } @item{ 2017.08班级博客前端迈向全栈入门篇。基于 Node.js + Express + ejs+ MongoDB + Bootstrap 搭建的班级博客系统。 } }"},{"title":"tags","date":"2017-07-07T13:18:56.000Z","updated":"2020-05-22T12:54:35.000Z","comments":false,"path":"tags/index.html","permalink":"https://pengfeidai.github.io/tags/index.html","excerpt":"","text":"您好！"}],"posts":[{"title":"etcd核心原理","slug":"etcd核心原理","date":"2020-06-05T14:52:28.000Z","updated":"2020-06-17T14:04:33.170Z","comments":true,"path":"2020/06/05/etcd核心原理/","link":"","permalink":"https://pengfeidai.github.io/2020/06/05/etcd核心原理/","excerpt":"","text":"etcd简介etcd 是一个高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据。在很多分布式系统架构中得到了广泛的应用，它内部采用 raft协议 作为一致性算法，基于Go语言实现。其主要功能有服务注册与发现、消息发布与订阅、负载均衡、分布式通知与协调、分布式锁、分布式队列、集群监控与 leader 选举等。 主要具有以下几个特点： 简单：安装配置简单，易于部署，易使用。基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。 安全：支持 SSL 证书验证。 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中。 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应。 快速：根据官方提供的 benchmark 数据，单实例支持每秒 2k+ 读操作。 可靠：采用raft算法，实现分布式系统数据的可用性和一致性。 存储特点etcd 是一个 键值存储 的组件，其他的应用都是基于其键值存储的功能展开。etcd 的存储有如下特点： 采用kv型数据存储，一般情况下比关系型数据库快。 支持动态存储(内存)以及静态存储(磁盘)。 分布式存储，可集成为多节点集群。 存储方式，采用类似目录结构。 只有叶子节点才能真正存储数据，相当于文件。 叶子节点的父节点一定是目录，目录不能存储数据。 etcd应用场景etcd 的场景默认处理的数据都是系统中的控制数据。所以etcd在系统中的角色不是其他NoSQL产品的替代品，更不能作为应用的主要数据存储。etcd中应该 尽量只存储系统中服务的配置信息，对于应用数据只推荐把数据量很小，但是更新和访问频次都很高的数据存储在etcd中。 服务发现（Service Discovery）服务发现要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。 要解决服务发现的问题，需要具备下面三种必备属性： 一个强一致性、高可用的服务存储目录。 基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。 一种注册服务和监控服务健康状态的机制。 用户可以在etcd中注册服务，并且对注册的服务配置 key TTL，定时保持服务的心跳以达到监控健康状态的效果。 一种查找和连接服务的机制。 通过在 etcd 指定的主题（由服务名称构成的服务目录）下注册的服务也能在对应的主题下查找到。 images 消息发布与订阅在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"etcd","slug":"etcd","permalink":"https://pengfeidai.github.io/tags/etcd/"},{"name":"分布式","slug":"分布式","permalink":"https://pengfeidai.github.io/tags/分布式/"}]},{"title":"Protobuf生成Go代码","slug":"Protobuf生成Go代码指南","date":"2020-05-31T13:58:21.000Z","updated":"2020-06-03T17:24:43.000Z","comments":true,"path":"2020/05/31/Protobuf生成Go代码指南/","link":"","permalink":"https://pengfeidai.github.io/2020/05/31/Protobuf生成Go代码指南/","excerpt":"","text":"Protobuf简介Protobuf是Protocol Buffers的简称，由Google公司开发的一种数据描述语言，用于描述一种轻便高效的结构化数据存储格式，它可用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的数据载体，很适合做数据存储或 RPC 数据交换格式，它序列化出来的数据量少再加上以 K-V 的方式来存储数据，对消息的版本兼容性非常强，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。开发者可以通过Protobuf附带的工具生成代码并实现将结构化数据序列化的功能。 Protobuf中最基本的数据单元是message，是类似Go语言中结构体的存在。在message中可以嵌套message或其它的基础数据类型的成员。 protoc安装到 https://github.com/google/protobuf/releases 下载对应的buf，然后进行编译后，使用 protoc --version 能查看对应版本，说明安装成功。 环境变量配置第一步：if zsh vim ~/.zshrc; if bash vim ~/.bash_profile123export GOPATH=\"/Users/zl/go\"export GOBIN=\"/Users/zl/go/bin\"export PATH=\"$PATH:$GOPATH:$GOBIN\" 第二步：source ~/.zshrc || source ~/.bash_profile 第三步: 查看环境变量 1echo $PATH 注意： 以上配置具体路径 GOPATH 和 GOBIN 根实际填写即可，可使用go env查看。 编译器Protobuf核心的工具集是C++语言开发的，官方的protoc编译器中并不支持Go语言，需要安装插件才能生成Go代码。用如下命令安装： 1go get github.com/golang/protobuf/protoc-gen-go 它提供了一个 protoc-gen-go 二进制文件，当编译器调用时传递了--go_out 命令行标志时 protoc 就会使用它。–go_out代表输出的扩展名为 .pb.go 的文件。编译器会为每个.proto文件生成一个单独的源代码文件。 注意： proto路径（使用–proto_path或-I命令行标志指定）将替换为输出路径（使用–go_out标志指定）。 扩展: go-micro 是go语言中一个很好的微服务框架，功能完善。关于 micro 后面再做详细介绍。它也有个相对应的插件： 1go get github.com/micro/protoc-gen-micro 定义proto文件先在 proto 目录下新建一个 hello.proto 文件： 12345678910111213syntax = \"proto3\";message HelloRequest &#123; string name = 1;&#125;message HelloResponse &#123; string greeting = 1;&#125;service Greeter &#123; rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;&#125; 生成原型1protoc --proto_path=. --go_out=. */*.proto 编译器会读取proto目录下所有后缀名为 .proto的文件，这将会生成一个输出文件 product.pb.go。 包默认规则如果一个.proto文件中有包声明，生成的源代码将会使用它来作为Go的包名，如果.proto的包名中有 . 在Go包名中会将 . 转换为 _。举例来说proto包名 example.hello 将会生成Go包名example_hello。 指定包名在.proto文件中可以使用option go_package 指令来覆盖上面默认生成Go包名的规则。比如说包含如下指令的一个.proto文件： 12package example.hello;option go_package = \"proto;hello\"; &quot;proto;hello&quot;：proto表示目录，hello 则是生成的Go源代码的包名是。 不指定包名如果一个.proto文件中不包含package声明，生成的源代码将会使用.proto文件的文件名(去掉扩展名)作为Go包名，.会被首先转换为_。如：hello.proto 文件默认生成源文件的包名为 hello。 import其他proto","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://pengfeidai.github.io/tags/Go/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://pengfeidai.github.io/tags/Protobuf/"},{"name":"RPC","slug":"RPC","permalink":"https://pengfeidai.github.io/tags/RPC/"}]},{"title":"micro微服务","slug":"micro微服务","date":"2020-05-30T14:52:28.000Z","updated":"2020-05-31T13:33:52.000Z","comments":true,"path":"2020/05/30/micro微服务/","link":"","permalink":"https://pengfeidai.github.io/2020/05/30/micro微服务/","excerpt":"","text":"docker安装consul -server：以服务端方式启动 -bootstrap：指定自己为leader，不需要选举 -ui：启动内置管理web界面 -client：指定客户端可以访问的ip。 12345# 安装docker pull consul# 启动docker run -d --name=consul -p 8500:8500 consul agent -server -bootstrap -ui -client 0.0.0.0","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"Gin","slug":"Gin","permalink":"https://pengfeidai.github.io/tags/Gin/"},{"name":"micro","slug":"micro","permalink":"https://pengfeidai.github.io/tags/micro/"}]},{"title":"使用Golang构建gRPC服务","slug":"使用Golang构建gRPC服务","date":"2020-05-24T14:52:28.000Z","updated":"2020-05-31T13:34:21.000Z","comments":true,"path":"2020/05/24/使用Golang构建gRPC服务/","link":"","permalink":"https://pengfeidai.github.io/2020/05/24/使用Golang构建gRPC服务/","excerpt":"","text":"本教程提供了Go使用gRPC的基础教程 在教程中你将会学到如何： 在 .proto 文件中定义一个服务。 使用protocol buffer编译器生成客户端和服务端代码。 使用gRPC的Go API为你的服务写一个客户端和服务器。 为什么使用gRPC借助gRPC，我们可以在 .proto 文件中定义我们的服务，并以gRPC支持的任何语言来实现客户端和服务器，客户端和服务器又可以在从服务器到你自己的平板电脑的各种环境中运行-gRPC还会为你解决所有不同语言和环境之间通信的复杂性。我们还获得了使用protocol buffer的所有优点，包括有效的序列化（速度和体积两方面都比JSON更有效率）；简单的IDL（接口定义语言）和轻松的接口更新。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"gPRC","slug":"gPRC","permalink":"https://pengfeidai.github.io/tags/gPRC/"}]},{"title":"Golang中etcd使用教程","slug":"golang中etcd使用","date":"2020-05-13T14:52:28.000Z","updated":"2020-05-26T15:00:07.000Z","comments":true,"path":"2020/05/13/golang中etcd使用/","link":"","permalink":"https://pengfeidai.github.io/2020/05/13/golang中etcd使用/","excerpt":"","text":"安装pakcgae我们使用的是v3版本的etcd client， 首先通过go get下载并编译安装etcd clinet v3。 文档地址：https://godoc.org/github.com/coreos/etcd/clientv3 1go get github.com/coreos/etcd/clientv3 所有相关依赖包会自动下载编译，包括protobuf、grpc等。这里需要注意需要将 go.mod 中添加一行，使用grpc的v1.26.0版本，否则后面连接会报错：undefined: balancer.PickOptions 1replace google.golang.org/grpc =&gt; google.golang.org/grpc v1.26.0 连接客户端创建客户端使用 clientv3.New，它需要传入一个Config配置，这里传了2个选项： Endpoints：etcd的多个节点服务地址。 DialTimeout：创建client的首次连接超时时间，这里传了5秒，如果5秒都没有连接成功就会返回err；一旦client创建成功，我们就不用再关心后续底层连接的状态了，client内部会重连。 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"context\" \"fmt\" \"time\" \"github.com/coreos/etcd/clientv3\")var defaultTimeout = 5 * time.Secondvar Client *clientv3.Clientfunc Init() *clientv3.Client &#123; cli, err := clientv3.New(clientv3.Config&#123; Endpoints: []string&#123;\"localhost:2379\"&#125;, DialTimeout: defaultTimeout, &#125;) if err != nil &#123; fmt.Println(\"clientv3 Init error:\", err) panic(err) &#125; Client = cli fmt.Println(\"clientv3 Init success\") return cli&#125;func main() &#123; // \b\b初始化 cli := Init() defer cli.Close()&#125; 返回的 client类型中，几个etcd客户端核心功能模块如下： Cluster：向集群里增加etcd服务端节点之类，属于管理员操作。 KV：我们主要使用的功能，即K-V键值库的操作。 Lease：租约相关操作，比如申请一个TTL=10秒的租约（应用给key可以实现键值的自动过期）。 Watcher：观察订阅，从而监听最新的数据变化。 Auth：管理etcd的用户和权限，属于管理员操作。 Maintenance：维护etcd，比如主动迁移etcd的leader节点，属于管理员操作。 Client.KV Client.KV 是我们平时主要使用的功能，它是一个 interface，提供了所有关于K-V操作的方法，我们前面通过 etcdctl 执行的相关命令，都可以在这里来操作。 我们通过方法 clientv3.NewKV() 来获得KV接口的实现（实现中内置了错误重试机制）： 12345func main() &#123; ... kv := clientv3.NewKV(cli)&#125; 接下来，我们将通过 kv 操作etcd中的数据。 Putetcd v3使用gRPC进行远程程序调用，并且clientv3使用 grpc-go 连接etcd。确保在使用完客户端后关闭它，如果客户端没有关闭，连接将会有泄漏的goroutines。指定超时时间，通过 context.WithTimeout 使用APIs: 函数声明如下：1Put(ctx context.Context, key, val string, opts ...OpOption) (*PutResponse, error) 第一个参数是goroutine的上下文Context。后面两个参数分别是key和value；另外，还支持一个变长参数 ，可以传递一些控制项来影响Put的行为，例如可以携带一个lease ID来支持key过期。 例：123456ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)putResp, err := kv.Put(ctx, \"/test\", \"Hello world\")cancel()fmt.Println(putResp)// &amp;&#123;cluster_id:14841639068965178418 member_id:10276657743932975437 revision:28 raft_term:5 &lt;nil&gt; &#123;&#125; [] 0&#125; 我们需要判断err来确定操作是否成功。 不同的KV操作对应不同的response结构，所有KV操作返回的response结构如下： 1234567type ( CompactResponse pb.CompactionResponse PutResponse pb.PutResponse GetResponse pb.RangeResponse DeleteResponse pb.DeleteRangeResponse TxnResponse pb.TxnResponse) Get函数声明如下：123456789// Get retrieves keys.// By default, Get will return the value for \"key\", if any.// When passed WithRange(end), Get will return the keys in the range [key, end).// When passed WithFromKey(), Get returns keys greater than or equal to key.// When passed WithRev(rev) with rev &gt; 0, Get retrieves keys at the given revision;// if the required revision is compacted, the request will fail with ErrCompacted .// When passed WithLimit(limit), the number of returned keys is bounded by limit.// When passed WithSort(), the keys will be sorted.Get(ctx context.Context, key string, opts ...OpOption) (*GetResponse, error) 我们可以传递一些控制参数来影响Get的行为，比如：WithFromKey表示读取从参数key开始递增的所有key，而不是读取单个key。 例：使用KV的Get方法来读取给定键的值： 123456resp, err := kv.Get(context.TODO(), \"/test\")for _, ev := range resp.Kvs &#123; fmt.Printf(\"%s : %s\\n\", ev.Key, ev.Value) // \"/test\": \"hello world\" &#125; 上面的例子中，没有传递opOption，所以就是获取 key=/test 的最新版本数据。 12345678910type RangeResponse struct &#123; Header *ResponseHeader `protobuf:\"bytes,1,opt,name=header\" json:\"header,omitempty\"` // kvs is the list of key-value pairs matched by the range request. // kvs is empty when count is requested. Kvs []*mvccpb.KeyValue `protobuf:\"bytes,2,rep,name=kvs\" json:\"kvs,omitempty\"` // more indicates if there are more keys to return in the requested range. More bool `protobuf:\"varint,3,opt,name=more,proto3\" json:\"more,omitempty\"` // count is set to the number of keys within the range when requested. Count int64 `protobuf:\"varint,4,opt,name=count,proto3\" json:\"count,omitempty\"`&#125; Kvs字段，保存了Get查询到的所有k-v对，因为上述例子只Get了一个单key，所以只需要判断一下 len(Kvs) 是否等于1即可知道key是否存在。 RangeResponse.More 和 Count，当我们使用 withLimit() 等选项进行Get时会发挥作用，相当于翻页查询。 WithPrefix前缀匹配1rangeResp, err := kv.Get(context.TODO(), &quot;/test/&quot;, clientv3.WithPrefix()) WithPrefix() 是指查找以/test/为前缀的所有key，因此可以模拟出查找子目录的效果。 etcd是一个有序的k-v存储，因此 /test/ 为前缀的key总是顺序排列在一起。 withPrefix()实际上会转化为范围查询，它根据前缀/test/生成了一个前闭后开的 key range：[“/test/”, “/test0”)，为什么呢？因为比/大的字符是0，所以以/test0作为范围的末尾，就可以扫描到所有以/test/为前缀的key了。 Leaseetcd客户端的Lease对象可以通过以下的代码获取到 1lease := clientv3.NewLease(cli) Lease提供了功能如下： Grant：分配一个租约。 Revoke：释放一个租约。 TimeToLive：获取剩余TTL时间。 Leases：列举所有etcd中的租约。 KeepAlive：自动定时的续约某个租约。 KeepAliveOnce：为某个租约续约一次。 Close：释放当前客户端建立的所有租约。 要想实现key自动过期，首先得创建一个租约，下面的代码创建一个TTL为60秒的租约： 1grantResp, err := lease.Grant(context.TODO(), 10) 返回的grantResponse的结构体： 1234567// LeaseGrantResponse wraps the protobuf message LeaseGrantResponse.type LeaseGrantResponse struct &#123; *pb.ResponseHeader ID LeaseID TTL int64 Error string&#125; 接下来我们用这个Lease往etcd中存储一个60秒过期的key： 1putResp, err := kv.Put(context.TODO(), \"/test/key1\", \"hello world\", clientv3.WithLease(grantResp.ID)) 注意： 如果Put之前Lease已经过期了，那么这个Put操作会返回error，此时需要重新分配Lease。 实现服务注册时，需要主动给Lease进行续约，通常是以小于TTL的间隔循环调用Lease的 KeepAliveOnce() 方法对租约进行续期，一旦某个服务节点出错无法完成租约的续期，等key过期后客户端即无法在查询服务时获得对应节点的服务，这样就通过租约到期实现了服务的错误隔离。 1keepResp, err := lease.KeepAliveOnce(context.TODO(), grantResp.ID) Txn事务etcd中事务是 原子执行 的，只支持 if … then … else … 这种表达。首先来看一下Txn中定义的方法： 1234567891011121314151617type Txn interface &#123; // If takes a list of comparison. If all comparisons passed in succeed, // the operations passed into Then() will be executed. Or the operations // passed into Else() will be executed. If(cs ...Cmp) Txn // Then takes a list of operations. The Ops list will be executed, if the // comparisons passed in If() succeed. Then(ops ...Op) Txn // Else takes a list of operations. The Ops list will be executed, if the // comparisons passed in If() fail. Else(ops ...Op) Txn // Commit tries to commit the transaction. Commit() (*TxnResponse, error)&#125; \b通过KV对象开启一个事务：1txn := kv.Txn(context.TODO()) 例：下面的测试程序，判断如果key的版本号是2，则Put 键值k1和k2，否则Put键值k3和4。 1234567kv.Txn(context.TODO()).If( clientv3.Compare(clientv3.Version(key), \"=\", 2)).Then( clientv3.OpPut(k1,v1), clentv3.OpPut(k2,v2)).Else( clientv3.OpPut(k3,v3), clientv3.OpPut(k4,v4)).Commit() WatchWatch用于 监听某个键的变化, Watch调用后返回一个 WatchChan，它的类型声明如下: 123456789101112type WatchChan &lt;-chan WatchResponsetype WatchResponse struct &#123; Header pb.ResponseHeader Events []*Event CompactRevision int64 Canceled bool Created bool&#125; 当监听的key有变化后会向 WatchChan 发送 WatchResponse。 应用场景：系统配置的热加载，我们可以在系统读取到存储在etcd key中的配置后，用Watch监听key的变化。在单独的 goroutine 中接收WatchChan发送过来的数据，并将更新应用到系统设置的配置变量中，这样系统就实现了配置变量的热加载。 12345678910111213141516171819202122type Config struct &#123; config1 string config2 string&#125;var appConfig Appconfigfunc watchConfig(clt *clientv3.Client, key string, c interface&#123;&#125;) &#123; watchCh := clt.Watch(context.TODO(), key) go func() &#123; for res := range watchCh &#123; value := res.Events[0].Kv.Value if err := json.Unmarshal(value, c); err != nil &#123; fmt.Println(\"watchConfig err:\", err) continue &#125; fmt.Println(\"watchConfig\", c) &#125; &#125;()&#125;watchConfig(client, \"config_key\", &amp;Config)","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"etcd","slug":"etcd","permalink":"https://pengfeidai.github.io/tags/etcd/"},{"name":"分布式","slug":"分布式","permalink":"https://pengfeidai.github.io/tags/分布式/"}]},{"title":"Galang常用包整理","slug":"Galang常用包整理","date":"2020-05-12T14:52:28.000Z","updated":"2020-06-03T14:20:05.000Z","comments":true,"path":"2020/05/12/Galang常用包整理/","link":"","permalink":"https://pengfeidai.github.io/2020/05/12/Galang常用包整理/","excerpt":"","text":"godocgodoc 开发框架 gin beego 数据库 mysql momgo redis 微服务框架 micro 工具类 protobuf logrus","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"}]},{"title":"etcd技术原理探究","slug":"etcd技术原理探究","date":"2020-05-12T14:52:28.000Z","updated":"2020-05-25T17:13:01.000Z","comments":true,"path":"2020/05/12/etcd技术原理探究/","link":"","permalink":"https://pengfeidai.github.io/2020/05/12/etcd技术原理探究/","excerpt":"","text":"etcd简介etcd 是一个高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据。在很多分布式系统架构中得到了广泛的应用，它内部采用 raft协议 作为一致性算法，基于Go语言实现。其主要功能有服务注册与发现、消息发布与订阅、负载均衡、分布式通知与协调、分布式锁、分布式队列、集群监控与 leader 选举等。 主要具有以下几个特点： 简单：安装配置简单，易于部署，易使用。基于 HTTP 的 API 让你用 curl 就可以轻松使用。 安全：支持 SSL 证书验证。 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中。 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应。 快速：根据官方提供的 benchmark 数据，单实例支持每秒 2k+ 读操作。 可靠：采用raft算法，实现分布式系统数据的可用性和一致性。 存储特点etcd 是一个 键值存储 的组件，其他的应用都是基于其键值存储的功能展开。etcd 的存储有如下特点： 采用kv型数据存储，一般情况下比关系型数据库快。 支持动态存储(内存)以及静态存储(磁盘)。 分布式存储，可集成为多节点集群。 存储方式，采用类似目录结构。 只有叶子节点才能真正存储数据，相当于文件。 叶子节点的父节点一定是目录，目录不能存储数据。 etcd应用场景etcd 的场景默认处理的数据都是系统中的控制数据。所以etcd在系统中的角色不是其他NoSQL产品的替代品，更不能作为应用的主要数据存储。etcd中应该 尽量只存储系统中服务的配置信息，对于应用数据只推荐把数据量很小，但是更新和访问频次都很高的数据存储在etcd中。 服务发现（Service Discovery）服务发现要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。 要解决服务发现的问题，需要具备下面三种必备属性： 一个强一致性、高可用的服务存储目录。 基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。 一种注册服务和监控服务健康状态的机制。 用户可以在etcd中注册服务，并且对注册的服务配置 key TTL，定时保持服务的心跳以达到监控健康状态的效果。 一种查找和连接服务的机制。 通过在 etcd 指定的主题（由服务名称构成的服务目录）下注册的服务也能在对应的主题下查找到。 etcd架构图 images 从上图中我们可以看到，etcd 主要分为四个部分。 HTTP Server：用于处理用户发送的 API 请求以及其它 etcd 节点的同步与心跳信息请求。 Store：用于处理 etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 etcd 对用户提供的大多数 API 功能的具体实现。 Raft：Raft 强一致性算法的具体实现，是 etcd 的核心。 WAL：Write Ahead Log（预写式日志），是 etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容。 通常，一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理，如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 etcd 节点以确认数据提交，最后进行数据的提交，再次同步。 消息发布与订阅在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个 配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。 images 应用中用到的一些 配置信息 放到etcd上进行集中管理。使用方式：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。 分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。 分布式日志收集系统，这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个 etcd 递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。 用户从集群中哪个节点读写数据？为了保证数据的强一致性，etcd集群中所有的数据流向都是一个方向，从 Leader （主节点）流向 Follower，也就是所有 Follower 的数据必须与 Leader 保持一致，如果不一致会被覆盖。 简单点说就是，用户可以对etcd集群中的所有节点进行读写，读取非常简单因为每个节点保存的数据是强一致的。对于写入来说，etcd集群中的节点会选举出Leader节点，如果写入请求来自Leader节点即可直接写入然后Leader节点会把写入分发给所有Follower，如果写入请求来自其他Follower节点那么写入请求会给转发给Leader节点，由Leader节点写入之后再分发给集群上的所有其他节点。 如何选举Leader节点假设集群中有三个节点，集群启动之初节点中并没有被选举出的Leader。 Raft算法使用 随机Timer 来初始化Leader选举流程。比如说在上面三个节点上都运行了Timer（每个Timer的持续时间是随机的），第一个节点率先完成了Timer，随后它就会向其他两个节点发送成为Leader的请求，其他节点接收到请求后会以 投票回应 然后第一个节点被选举为Leader。 成为Leader后，该节点会 以固定时间间隔向其他节点发送通知，确保自己仍是Leader。 有些情况下当Follower们收不到Leader的通知后，比如说Leader节点宕机或者失去了连接，其他节点会重复之前选举过程选举出新的Leader。 判断写入是否成功etcd认为写入请求被Leader节点处理并分发给了 多数节点 后，就是一个成功的写入。如何界定多数节点呢？假设总结点数是N，那么界定多数节点的公式是 Quorum=N/2+1。 容错节点数：集群中节点总数(Instances)对应的Quorum数量，用Instances减去Quorom就是集群中容错节点（允许出故障的节点）的数量。 所以在集群中推荐的最少节点数量是3个，因为1和2个节点的容错节点数都是0，一旦有一个节点宕掉整个集群就不能正常工作了。 123456789Instances Quorum Fault Toleran1 1/2+1=1 1-1=02 2/2+1=2 2-2=03 3/2+1=2 3-2=14 3 15 3 26 4 27 4 3 如上所示：当决定集群中节点的数量时，强烈推荐奇数数量的节点。 例如：6个节点的集群它的容错能力并没有比5个节点的好，他们的容错节点数一样，一旦容错节点超过2后，由于Quorum节点数小于4整个集群也变为不可用的状态了。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"etcd","slug":"etcd","permalink":"https://pengfeidai.github.io/tags/etcd/"},{"name":"分布式","slug":"分布式","permalink":"https://pengfeidai.github.io/tags/分布式/"}]},{"title":"初识etcd","slug":"初识 etcd","date":"2020-05-10T14:52:28.000Z","updated":"2020-05-25T17:07:41.000Z","comments":true,"path":"2020/05/10/初识 etcd/","link":"","permalink":"https://pengfeidai.github.io/2020/05/10/初识 etcd/","excerpt":"","text":"简介etcd 是一个 golang 编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值(key-value)存储、配置共享和服务发现等功能。etcd可以用于存储关键数据和实现分布式调度，在现代化的集群运行中能够起到关键性的作用。 etcd基于 raft协议，通过复制日志文件的方式来保证数据的强一致性。在etcd之前，常用的是基于paxos协议的zookeeper。 单机安装etcdetcd在生产环境中一般推荐集群方式部署。在这里，主要讲讲单节点安装和基本使用。 CentOS 1yum install -y etcd 启动1234567891011121314151617181920212223242526# 设置开机自启动$ systemctl enable etcd# 启动etcd$ systemctl start etcd# 查看etcd运行状态$ systemctl status etcd● etcd.service - Etcd Server Loaded: loaded (/usr/lib/systemd/system/etcd.service; disabled; vendor preset: disabled) Active: active (running) since Sun 2020-05-24 23:08:57 CST; 7s ago Main PID: 20272 (etcd) Tasks: 8 Memory: 10.0M CGroup: /system.slice/etcd.service └─20272 /usr/bin/etcd --name=default --data-dir=/var/lib/etcd/default.etcd --listen-client-urls=http://localhost:2379May 24 23:08:57 VM_0_3_centos etcd[20272]: 8e9e05c52164694d received MsgVoteResp from 8e9e05c52164694d at term 2May 24 23:08:57 VM_0_3_centos etcd[20272]: 8e9e05c52164694d became leader at term 2May 24 23:08:57 VM_0_3_centos etcd[20272]: raft.node: 8e9e05c52164694d elected leader 8e9e05c52164694d at term 2May 24 23:08:57 VM_0_3_centos etcd[20272]: setting up the initial cluster version to 3.3May 24 23:08:57 VM_0_3_centos etcd[20272]: published &#123;Name:default ClientURLs:[http://localhost:2379]&#125; to cluster cdf818194e3a8c32May 24 23:08:57 VM_0_3_centos etcd[20272]: ready to serve client requestsMay 24 23:08:57 VM_0_3_centos etcd[20272]: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!May 24 23:08:57 VM_0_3_centos systemd[1]: Started Etcd Server.May 24 23:08:57 VM_0_3_centos etcd[20272]: set the initial cluster version to 3.3May 24 23:08:57 VM_0_3_centos etcd[20272]: enabled capabilities for version 3.3 systemd配置从 systemctl status etcd 命令的输出可以看到，etcd的 systemd配置文件位于 /usr/lib/systemd/system/etcd.service，该配置文件的内容如下： 123456789101112131415161718[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/var/lib/etcd/EnvironmentFile=-/etc/etcd/etcd.confUser=etcd# set GOMAXPROCS to number of processorsExecStart=/bin/bash -c \"GOMAXPROCS=$(nproc) /usr/bin/etcd --name=\\\"$&#123;ETCD_NAME&#125;\\\" --data-dir=\\\"$&#123;ETCD_DATA_DIR&#125;\\\" --listen-client-urls=\\\"$&#123;ETCD_LISTEN_CLIENT_URLS&#125;\\\"\"Restart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.target 从上面可以看出，etcd的配置文件： EnvironmentFile=-/etc/etcd/etcd.conf。如果我们想要修改某些配置项，可以编辑该文件。 远程访问etcd安装完成后，默认只能本机访问，如果想要其他主机访问，还需要修改 /etc/etcd/etcd.conf 中的配置。例如，本实例安装etcd的机器IP是 127.0.0.1（下面服务器ip用127.0.0.1替代，自己根据实际更改），在自己的机器远程访问服务器上安装的etcd的2379端口，结果访问被拒绝： 1234$ telnet 127.0.0.1 2379Trying 127.0.0.1...telnet: connect to address 127.0.0.1: Connection refusedtelnet: Unable to connect to remote host 修改 /etc/etcd/etcd.conf 配置： 注意：此处 127.0.0.1 使用内网ip 1ETCD_LISTEN_CLIENT_URLS=\"http://127.0.0.1:2379,http://localhost:2379\" 重启etcd1$ systemctl restart etcd etcdctl 常用命令查看版本1234etcdctl -vetcdctl version: 3.3.11API version: 2 可以看到默认 API version: 2，由于etcdctl的版本2和版本3并不兼容，我们使用以下命令设置。 123456# 设置环境变量，版本3。export ETCDCTL_API=3etcdctl versionetcdctl version: 3.3.11API version: 3.3 COMMANDS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647get Gets the key or a range of keysput Puts the given key into the storedel Removes the specified key or range ofkeys [key, range_end)txn Txn processes all the requests in onetransactioncompaction Compacts the event history in etcdalarm disarm Disarms all alarmsalarm list Lists all alarmsdefrag Defragments the storage of the etcdmembers with given endpointsendpoint health Checks the healthiness ofendpoints specified in `--endpoints` flagendpoint status Prints out the status ofendpoints specified in `--endpoints` flagendpoint hashkv Prints the KV history hash foreach endpoint in --endpointsmove-leader Transfers leadership to another etcdcluster member.watch Watches events stream on keys orprefixesversion Prints the version of etcdctllease grant Creates leaseslease revoke Revokes leaseslease timetolive Get lease informationlease list List all active leaseslease keep-alive Keeps leases alive (renew)member add Adds a member into the clustermember remove Removes a member from the clustermember update Updates a member in the clustermember list Lists all members in the clustersnapshot save Stores an etcd node backendsnapshot to a given filesnapshot restore Restores an etcd member snapshotto an etcd directorysnapshot status Gets backend snapshot statusof a given filemake-mirror Makes a mirror at the destinationetcd clustermigrate Migrates keys in a v2 store to amvcc storelock Acquires a named lockelect Observes and participates in leaderelectionauth enable Enables authenticationauth disable Disables authenticationuser add Adds a new useruser delete Deletes a useruser get Gets detailed information of a useruser list Lists all usersuser passwd Changes password of useruser grant-role Grants a role to a useruser revoke-role Revokes a role from a userrole add Adds a new rolerole delete Deletes a rolerole get Gets detailed information of a rolerole list Lists all rolesrole grant-permission Grants a key to a rolerole revoke-permission Revokes a key from a rolecheck perf Check the performance of the etcdclusterhelp Help about any command 查看集群状态和节点1etcdctl member list 插入数据可以把key理解成目录 12345678etcdctl put /hello/key1 \"world1\"OKetcdctl put /hello/key2 \"world2\"OKetcdctl put /hello/key3 \"world3\"OK 根据key查询1234etcdctl get /hello/key1/hello/key1world1 删除一条数据123etcdctl del /hello/key31 批量获取目录下的内容12345678910111213141516171819# 获取key valueetcdctl get /hello/ --prefix# 返回值/hello/key1world1/hello/key2world2#只获取keyetcdctl get /hello/ --prefix --keys-only# 返回值/hello/key1/hello/key2# 只获取valueetcdctl get /hello/ --prefix --print-value-only# 返回值world1world2 watch监听key1etcdctl watch /hello/key1 租约（可以理解成定时器，把key绑定上之后，到时间了key就被删除了）123456789101112131415etcdctl lease grant 60# 返回值lease 694d72477c721546 granted with TTL(60s)# 创建一条数据并绑定到上面租约上etcdctl put --lease=694d72477c721546 /hello/key3 \"world3\"# 马上获取数据etcdctl get /hello/key3 # 可以删除租约（对应的key也会被直接删除）etcdctl lease revoke 694d72477c721546# 续租（60s）etcdctl lease keep-alive 694d72477c721546 snapshot保存备份当前集群etcd的信息，用于新的etcd集群 12345etcdctl snapshot save snapshot.db# 返回Snapshot saved at snapshot.dblssnapshot.db 访问控制相关添加用户12345# root用户etcdctl user add root# 非root用户etcdctl user add mochu 添加role1etcdctl role add admin 将用户加入角色中1etcdctl user grant-role mochu admin 本文只介绍简单的指令，仅供学习使用，更多详细命令，请查看官方文档。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://pengfeidai.github.io/tags/Golang/"},{"name":"etcd","slug":"etcd","permalink":"https://pengfeidai.github.io/tags/etcd/"},{"name":"分布式","slug":"分布式","permalink":"https://pengfeidai.github.io/tags/分布式/"}]},{"title":"新机器nginx安装机器使用","slug":"新机器nginx安装及其使用","date":"2020-05-05T14:52:28.000Z","updated":"2020-05-25T17:07:29.000Z","comments":true,"path":"2020/05/05/新机器nginx安装及其使用/","link":"","permalink":"https://pengfeidai.github.io/2020/05/05/新机器nginx安装及其使用/","excerpt":"","text":"1. 安装依赖1234567891011#gcc安装，nginx源码编译需要yum install gcc-c++#PCRE pcre-devel 安装，nginx 的 http 模块使用 pcre 来解析正则表达式yum install -y pcre pcre-devel#zlib安装，nginx 使用zlib对http包的内容进行gzipyum install -y zlib zlib-devel#OpenSSL 安装，强大的安全套接字层密码库，nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http）yum install -y openssl openssl-devel 2. 使用wget命令下载（推荐）12# 版本自行选择稳定版即可wget -c https://nginx.org/download/nginx-1.16.1.tar.gz 3. 安装123456789101112131415161718192021222324252627282930313233# 解压到指定目录tar -zxvf nginx-1.16.1.tar.gz -C /opt/bin# 进入目录cd /opt/bin/nginx-1.16.1#使用默认配置./configure#编译安装makemake install# 查找安装路径，默认都是这个路径[root@VM_0_3_centos nginx-1.16.1]# whereis nginxnginx: /usr/local/nginx# 启动、停止nginxcd /usr/local/nginx/sbin/./nginx #启动./nginx -s stop #停止，直接查找nginx进程id再使用kill命令强制杀掉进程./nginx -s quit #退出停止，等待nginx进程处理完任务再进行停止./nginx -s reload #重新加载配置文件，修改nginx.conf后使用该命令，新配置即可生效#重启nginx，建议先停止，再启动./nginx -s stop./nginx#查看nginx进程[root@VM_0_12_centos ~]# ps aux|grep nginxroot 21888 0.0 0.0 20556 616 ? Ss 21:24 0:00 nginx: master process ./nginxnobody 21889 0.0 0.0 23092 1636 ? S 21:24 0:00 nginx: worker processroot 25687 0.0 0.0 112712 960 pts/0 R+ 21:52 0:00 grep --color=auto nginx 4. 设置开机自启动123456789# 第一步vi /etc/rc.local# 增加一行/usr/local/nginx/sbin/nginx#设置执行权限cd /etcchmod 755 rc.local 此时浏览器输入服务器ip即可访问 nginx 页面。 5. 配置域名映射nginx 配置文件都在 /usr/local/nginx/conf/ 目录下，文件名称是 nginx.conf。 12345# 进入nginx配置文件目录cd /usr/local/nginx/conf# 修改配置文件vi nginx.conf 域名配置： 只需要修改 server_name 和 location 里面的内容即可。 1234567listen 80;# 域名server_name www.example.com;# 访问地址的设置location / &#123;proxy_pass http://localhost:9000; &#125; 修改完成后，重新加载配置文件： 12cd /usr/local/nginx/sbin/./nginx -s reload 6. 静态资源访问（图片为例） 创建一个存储images的目录 1mkdir -p /opt/nginx/www/images 编辑配置 1234567891011121314# 修改用户权限user root;...server &#123; listen 8000; server_name localhost; location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; root /opt/nginx/www/images/; autoindex on; # 打开浏览功能 &#125;&#125; 重启nginx服务 1systemctl restart nginx 或 nginx -s reload 在浏览器访问测试","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://pengfeidai.github.io/tags/nginx/"}]},{"title":"javascript数组方法总结","slug":"array","date":"2017-09-20T14:02:52.000Z","updated":"2017-09-30T15:18:30.000Z","comments":true,"path":"2017/09/20/array/","link":"","permalink":"https://pengfeidai.github.io/2017/09/20/array/","excerpt":"","text":"数组创建第一种，使用 Array 构造函数：123var arr1 = new Array(); //创建一个空数组var arr2 = new Array(10); // 创建一个包含10项的数组var arr3 = new Array(\"a\", \"b\",\"c\"); // 创建一个包含3个字符串的数组 第二种，使用数组字面量表示法：12var arr1 = []; //创建一个空数组var arr2 = [\"a\", \"b\", \"c\"]; // 创建一个包含3个字符串的数组 在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：1234var arr = [\"a\", \"b\", \"c\"];console.log(arr[0]); // aarr[2] = \"d\"; // 将下标为2的 c 修改为 darr[3] = \"e\"; // 增加第四项为e JavaScript中数组的length属性是可以修改的，看下面的示例：123var arr = [\"a\", \"b\", \"c\"];arr[arr.length] = \"d\"; // 在数组尾部添加一项\"d\"arr.length = arr.length-1; //将最后一项删除 如何判断一个变量是不是数组对象1234567var arr = [];// ES5之前arr instanceof Array;// ES5新增arr.isArray();typeof arr; // object 数组方法join()join()：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [\"a\", \"b\", \"c\"];console.log(arr.join()); // a, b, cconsole.log(arr.join(\"-\")); // a-b-cconsole.log(arr); // [a, b, c]（原数组不变） 应用：通过join()方法可以实现重复字符串。1234function repeatString(str, n) &#123;return new Array(n + 1).join(str);&#125;console.log(repeatString(\"a\", 3)); // aaa push()和pop()push()：可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。1234567var arr = [\"a\", \"b\", \"c\"];var count = arr.push(\"d\", \"e\");console.log(count); // 5console.log(arr); // [\"a\", \"b\", \"c\", \"d\", \"e\"]var item = arr.pop();console.log(item); // econsole.log(arr); // [\"a\", \"b\", \"c\", \"d\"] shift() 和 unshift()shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift()：将参数添加到原数组开头，并返回数组的长度 。1234567var arr = [\"c\", \"d\", \"e\"];var count = arr.unshift(\"a\",\"b\");console.log(count); // 5console.log(arr); // [\"a\", \"b\", \"c\", \"d\", \"e\"]var item = arr.shift();console.log(item); // aconsole.log(arr); // [\"b\", \"c\", \"d\", \"e\"] sort()（原数组改变）sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串。123456var arr1 = [\"a\", \"d\", \"c\", \"b\"];console.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]console.log(arr1); // [\"a\", \"b\", \"c\", \"d\"]var arr2 = [15, 22, 46, 3];console.log(arr2.sort()); // [15, 22, 3, 46]console.log(arr2); // [15, 22, 3, 46] 解决方法：sort()方法可以接收一个比较函数作为参数，比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;arr2 = [15, 22, 46, 3];console.log(arr2.sort(compare)); // [3, 15, 22, 46] 如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可。12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;arr2 = [15, 22, 46, 3];console.log(arr2.sort(compare)); // [46, 22, 15, 3] reverse()（原数组改变）reverse()：反转数组项的顺序。123var arr = [15, 22, 46, 3];console.log(arr.reverse()); // [3, 46, 22, 15]console.log(arr); // [3, 46, 22, 15] concat()concat()：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。1234var arr = [1, 3, 5, 7];var arr1 = arr.concat(9, [11, 13]);console.log(arr1); // [1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7] 若传入的是一个二维数组。123var arr2 = arr.concat([9, [11, 13]]);console.log(arr2); // [1, 3, 5, 7, 9, Array[2]]console.log(arr2[5]); // [11, 13] slice()slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345678910var arr = [1, 3, 5, 7, 9, 11];var arr1 = arr.slice(1);var arr2 = arr.slice(1, 4);var arr3 = arr.slice(1, -2);var arr4 = arr.slice(-4, -1);console.log(arr); // [1, 3, 5, 7, 9, 11]console.log(arr1); // [3, 5, 7, 9, 11]console.log(arr2); // [3, 5, 7]console.log(arr3); // [3, 5, 7]console.log(arr4); // [5, 7, 9] arr1只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。arr2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。arr3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。arr4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2, 5)。 splice()splice()：可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。12345678910var arr = [1, 3, 5, 7, 9, 11];var arr1 = arr.splice(0, 2);console.log(arr); //[5, 7, 9, 11]console.log(arr1); //[1, 3]var arr2 = arr.splice(2, 0, 4, 6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrR2); // []var arr3 = arr.splice(1, 1, 2, 4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrR3); // [7] indexOf()和 lastIndexOf()indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。123456var arr = [1, 3, 5, 7, 7, 5, 3, 1];console.log(arr.indexOf(5)); // 2console.log(arr.lastIndexOf(5)); // 5console.log(arr.indexOf(5,2)); // 2console.log(arr.lastIndexOf(5, 4)); // 2console.log(arr.indexOf(\"5\")); // -1 forEach()forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：值，索引。1234567var arr = [1, 2, 3];arr.forEach(function(item, index)&#123;console.log(index, item);&#125;);// 0, 1// 1, 2// 2, 3 map()map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。下面代码利用map方法实现数组中每个数求平方。12345var arr = [1, 2, 3, 4];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); // [1, 4, 9, 16] filter()filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;);console.log(arr2); //[1, 4, 7, 8, 9, 10] every()every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123; return x &lt; 10;&#125;);console.log(arr2); // truevar arr3 = arr.every(function(x) &#123; return x &lt; 3;&#125;);console.log(arr3); // false some()some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123; return x &lt; 3;&#125;);console.log(arr2); // truevar arr3 = arr.some(function(x) &#123; return x &lt; 1;&#125;);console.log(arr3); // false reduce()和 reduceRight()这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。reduceRight()则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。12345var values = [1, 2, 3, 4, 5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;, 10);console.log(sum); //25","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengfeidai.github.io/tags/Javascript/"}]},{"title":"MongoDB学习笔记","slug":"MongoDB","date":"2017-09-10T13:58:21.000Z","updated":"2017-09-27T09:36:54.000Z","comments":true,"path":"2017/09/10/MongoDB/","link":"","permalink":"https://pengfeidai.github.io/2017/09/10/MongoDB/","excerpt":"","text":"简介什么是NoSQL?NoSQL，指的是非关系型的数据库。 没有行、列的概念。用 JSON 来存储数据。集合就相当于 SQL 数据库中的“表”，文档就相当于“行”。 适用于： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 什么是MongoDB?官网：https://www.mongodb.com 手册：https://docs.mongodb.org/manual MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB安装及运行下载最新的stable版：https://www.mongodb.com/download-center#community 安装好之后，我们看一下安装的文件夹，例如：C:\\Program Files\\MongoDB\\Server\\3.0\\bin，将其加入到系统的path环境变量中，那么我们就能在系统的任何盘符，使用mongo命令了。 123mongo 使用数据库mongod 开机mongoimport 导入数据 启动mongod服务 image –dbpath就是选择数据库文档所在的文件夹。 管理数据库（新开一个cmd） image 那么，运行环境就是mongo语法了。 MongoDB常用操作查看所有数据库1show dbs 使用数据库、创建数据库1use test use一个不存在的，就是新建。 查看当前所在数据库1db 插入数据数据库中不能直接插入数据，只能往集合(collections)中插入数据。不需要创建集合，只需要写点语法： 1db.student.insert(&#123;&quot;name&quot;:&quot;Davis&quot;,&quot;age&quot;:&quot;22&quot;,&quot;sex&quot;:&quot;男&quot;&#125;) db.student 系统发现student是一个陌生的集合名字，所以就自动创建了集合。 删除数据库删除当前数据库1db.dropDatabase(); 数据库使用插入数据插入数据，随着数据的插入，数据库创建成功了，集合也创建成功了。 1db.student.insert(&#123;&quot;name&quot;:&quot;Davis&quot;,&quot;age&quot;:&quot;22&quot;,&quot;sex&quot;:&quot;男&quot;&#125;) 我们不可能一条一条的insert。所以，我们希望用sublime在外部写好数据库的形式，然后导入数据库： 导入json1mongoimport --db test --collection student --drop --file data.json 导入json数组1mongoimport --db test --collection student --drop --file data.json --jsonArray -db test 想往哪个数据库里面导入--collection student 想往哪个集合中导入--drop 把已存在数据清空--file data.json 哪个文件 这样，我们就能用sublime创建一个json文件，然后用mongoimport命令导入。 查找数据 查找数据，用find。find中没有参数，那么将列出这个集合的所有文档： 1db.student.find() 精确匹配 1db.student.find(&#123;&quot;age&quot;:22&#125;) 多个条件 1db.student.find(&#123;&quot;age&quot;:12, &quot;sex&quot;:&quot;男&quot;&#125;) 大于条件 1db.student.find(&#123;&quot;age&quot;:&#123;$gt:20&#125;&#125;) 或者（寻找所有年龄是20岁，或者22岁的学生） 1db.student.find(&#123;$or:[&#123;&quot;age&quot;:20&#125;,&#123;&quot;age&quot;:22&#125;]&#125;); 查找完毕之后，打点调用sort，表示升（1）降（-1）排序 1db.student.find().sort(&#123;&quot;age&quot;:1, &quot;score.English&quot;:1&#125;) 查看当前Mongodb运行状态 1db.student.stats(); 分页查询 通过 sike() 与 limit() 方法 假如，第一页是page=0。每页10条，所以当前页的查询语句1db.student.find(&#123;&#125;).limit(10).skip(page*10) limit()表示读取的条数，sike()表示略过的条数。 修改数据 修改里面还有查询条件 查找名字叫做Davis的，把年龄更改为20岁：1db.student.update(&#123;&quot;name&quot;:&quot;Davis&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;) 更改所有匹配项目 1db.student.update(&#123;&quot;sex&quot;:&quot;男&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;,&#123;multi: true&#125;); 完整替换，不出现$set关键字了 1db.student.update(&#123;&quot;name&quot;:&quot;Davis&quot;&#125;,&#123;&quot;name&quot;:&quot;dpf&quot;,&quot;age&quot;:20&#125;); 删除数据 删除集合中高数成绩为 60 的学生 1db.student.remove(&#123;&apos;score.English&apos;:60&#125;); 删除第一条找到的记录可以设置 justOne 为 1 1db.student.remove(&#123;&apos;score.English&apos;:60&#125;,1); MongooseMongoose，是一个将JavaScript对象与数据库产生关系的一个框架，object related model。所有的操作都不是对数据库进行的。而是对类、实例进行的，对象产生了，同时也持久化了。 官网：http://mongoosejs.com/ 数据库连接1234567var mongoose = require('mongoose');//创建数据库连接var db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');//监听open事件db.once('open', function (callback) &#123; console.log(\"数据库成功连接\");&#125;); 定义模型 image 创造schema → 定义一些schema的静态方法 → 创造模型 创造schema1new mongoose.schema(&#123;&#125;); 创造模型1db.model(“Student”,schema名字); 1234567891011121314151617//创建了一个schema结构。var studentSchema = new mongoose.Schema(&#123; name : &#123;type : String&#125;, age : &#123;type : Number&#125;, sex : &#123;type : String&#125;&#125;);//创建静态方法studentSchema.statics.zhaoren = function(name, callback) &#123; this.model('Student').find(&#123;name: name&#125;, callback); //this.model('Student')指的是当前这个类&#125;;//创建修改的静态方法studentSchema.statics.xiugai = function(conditions,update,options,callback)&#123; this.model(\"Student\").update(conditions, update, options, callback);&#125;//创建了一个模型，就是学生模型，就是学生类。//类是基于schema创建的。var studentModel = db.model('Student', studentSchema); MongoVUE连接MongoDB不显示数据问题 mongoDB3.2版本之后默认开启的存储引擎是 wiredTiger，使用这种存储引擎存储的数据只能在命令行中看到，在 mongoVUE 中看不到。 所以，需要换成 mmapv1 操作引擎，此时就可以在 mongoVUE 中看到 Collections 下的内容1mongod --storageEngine mmapv1 --dbpath D:\\mongo(路径) 选择 mmapv1存储引擎后，ns 后缀文件就是数据库","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://pengfeidai.github.io/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://pengfeidai.github.io/tags/MongoDB/"},{"name":"mongoose","slug":"mongoose","permalink":"https://pengfeidai.github.io/tags/mongoose/"}]},{"title":"JavaScript最全设计模式详解","slug":"JavaScript设计模式","date":"2017-08-10T07:29:04.000Z","updated":"2020-05-22T12:14:57.000Z","comments":true,"path":"2017/08/10/JavaScript设计模式/","link":"","permalink":"https://pengfeidai.github.io/2017/08/10/JavaScript设计模式/","excerpt":"","text":"简介让系统代码可重用、可扩展、可解耦、更容易被人理解且保证代码可靠性。设计模式使代码真正工程化。 image 设计原则： 开闭原则： 对扩展开放，对修改关闭 里氏转换原则： 子类继承父类，单独完全可以运行 依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型 接口隔离原则： 每一个接口应该是一种角色 合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分 迪米特原则： 一个对象应对其他对象有尽可能少的了解 单例模式概念保证一个类只有一个实例，实现方法是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，确保一个类只有一个实例对象。 在 JavaScript 中，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 123456789101112131415161718192021222324var Singleton = (function () &#123; var instantiated; function init() &#123; /*这里定义单例代码*/ return &#123; publicMethod: function () &#123; console.log('hello world'); &#125;, publicProperty: 'test' &#125;; &#125; return &#123; getInstance: function () &#123; if (!instantiated) &#123; //确保只有一个实例 instantiated = init(); //使用init方法，是使publicMethod和publicProperty只在要使用的时候才初始化; &#125; return instantiated; &#125; &#125;;&#125;)();/*调用公有的方法来获取实例:*/Singleton.getInstance().publicMethod(); // hello world 作用和注意事项模式作用： 模块间通信 系统中某个类的对象只能存在一个 保护自己的属性和方法 注意事项： 注意this的使用 闭包容易造成内存泄露，不需要的要赶快清除 注意new的成本。（继承） 实例在网页上实现一个登陆弹框，无论我们点击多少次登陆按钮，界面上始终只会显示一个登陆弹框，无法再创建第二个。 源码下载 &nbsp;&nbsp;&nbsp; demo演示 （1）获取DOM对象123var $ = function(id) &#123; return typeof id === 'string' ? document.getElementById(id) : id;&#125;; 为了便于之后关于DOM的一些操作，我们这里利用函数式编程的原理将获取目标 id 的元素对象方法封装了一下，直接利用 $(id) 就可以获取。 （2）弹框构造函数12345var Modal = function(id, html) &#123; this.html = html; this.id = id; this.open = false;&#125;; 这里我们声明了一个 Modal 作为弹框的构造函数，并且再其内部定义了公有属性 html、id 和 open。html 用来定义弹框内部的内容，id 用来给弹框定义 id 名称，open 用于判断弹框是否打开。 （3）open方法123456789101112131415Modal.prototype.create = function() &#123; if (!this.open) &#123; var modal = document.createElement('div'); modal.innerHTML = this.html; modal.id = this.id; document.body.appendChild(modal); setTimeout(function() &#123; modal.classList.add('show'); &#125;, 0); this.open = true; &#125;&#125;; 在 Modal 的原型链上定义了 create 方法，方法内部我们创建并向 DOM 中插入弹框，同时给弹框加上一个 class 为 “show” 的动画效果。 （4）close方法123456789101112Modal.prototype.delete = function() &#123; if (this.open) &#123; var modal = $(this.id); modal.classList.add('hide'); setTimeout(function() &#123; document.body.removeChild(modal); &#125;, 200); this.open = false; &#125;&#125;; 定义了 open 方法后我们这里定义关闭弹框的方法，在其内部给弹框对象添加 hide 类动画效果，最后在页面上移除弹框对象。 （5）创建实例123456var createIntance = (function() &#123; var instance; return function() &#123; return instance || (instance = new Modal('modal', '这是一个弹框')) &#125;&#125;)(); 这是实现单例模式的重要部分: 使用闭包封装了 instance 私有变量并返回一个函数 利用 || 语法判断如果 instance 不存在则执行后者的实例化 Modal 方法，存在则直接返回 instance，确保了只存在一个弹框实例 （6）按钮操作12345678910var operate = &#123; setModal: null, open: function() &#123; this.setModal = createIntance(); this.setModal.create(); &#125;, delete: function() &#123; this.setModal ? this.setModal.delete() : ''; &#125;&#125;; 这里我们将按钮操作放在 operate 对象里，使得打开和关闭操作可以通过this获取实例setModal。 （7）绑定事件1234567$('open').onclick = function() &#123; operate.open();&#125;;$('delete').onclick = function() &#123; operate.delete();&#125;; 最后我们将打开和删除方法绑定到两个按钮上去，至此我们用单例模式实现的弹框demo就实现了。 构造函数模式概念 构造函数用于创建特定类型的对象——不仅声明了使用过的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。 作用和注意事项模式作用： 用于创建特定类型的对象 第一次声明的时候给对象赋值 自己声明构造函数，赋予属性和方法 注意事项： 声明函数的时候处理业务逻辑 区分和单例的区别，配合单例实现初始化 构造函数大写字母开头 注意 new 的成本 （继承） 实例强制使用new123456789101112131415161718function Person(name, age, job) &#123; if (!(this instanceof Person)) &#123; return new Person(name, age, job); &#125; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; return this.name + 'is' + this.age + 'years old'; &#125;&#125;var person1 = new Person(\"Davis\", 22, \"student\");var person2 = Person(\"Faker\", 21, \"player\");console.log(person1.sayName()); // Davis is 22 years oldconsole.log(person2.sayName()); // Faker is 21 years old 建造者模式概念 建造者模式可以将一个复杂的对象的构建与其表示相分离，使同样的构建过程可以创建不同的表示。如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。建造者模式实际就是一个指挥者，一个建造者，一个使用指挥者调用具体建造者工作得出结果的客户。主要用于“分步骤构建一个复杂的对象”。 作用和注意事项模式作用： 分步创建一个复杂的对象 解耦封装过程和具体创建组件 无需关心组件如何组装 注意事项： 一定要一个稳定的算法进行支持（“分步骤”是一个稳定的算法） 加工工艺是暴露的 实例一个土豪需要建一个别墅，然后直接找包工头，包工头再找工人把别墅建好。这里土豪不用直接一个一个工人的去找。只需包工头知道土豪需求，然后去找工人，工人干活，土豪也不需要知道房子具体怎么建，最后能拿到房就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1.产出东西是房子//2.包工头调用工人进行开工而且他要很清楚工人们具体的某一个大项//3.工人是盖房子的 工人可以建厨房、卧室、建客厅//4.包工头只是一个接口而已 他不干活 他只对外说我能建房子function House() &#123; this.kitchen = \"\"; this.bedroom = \"\"; this.livingroom = \"\";&#125;function Contractor() &#123; this.construct = function(worker) &#123; worker.construct_kitchen(); worker.construct_bedroom(); worker.construct_livingroom(); &#125;&#125;function Worker() &#123; this.construct_kitchen =function() &#123; console.log(\"厨房建好了\"); &#125; this.construct_bedroom = function() &#123; console.log(\"卧室建好了\"); &#125; this.construct_livingroom = function() &#123; console.log(\"客厅建好了\"); &#125; this.submit = function() &#123; var _house = new House(); _house.kitchen = \"finished\"; _house.bedroom = \"finished\"; _house.livingroom = \"finished\"; return _house; &#125;&#125;;var worker = new Worker();var contractor = new Contractor();contractor.construct(worker);// 主人要房子var myhouse = worker.submit();console.log(myhouse); 工厂模式概念工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型（抽象工厂）。 作用和注意事项模式作用： 对象构建十分复杂 需要依赖具体的环境创建不同的实例 处理大量具有相同属性的小对象 注意事项： 1、不能滥用工厂，有时候仅仅是给代码增加复杂度 实例简单工厂模式12345678910111213141516var XMLHttpFactory = function() &#123;&#125;;XMLHttpFactory.createXMLHttp = function() &#123; var XMLHttp = null; // XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象 if (window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp;&#125;;var AjaxHander = function() &#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); /*...具体操作... */&#125; 抽象工厂模式12345678910111213141516171819202122232425262728var XMLHttpFactory = function() &#123;&#125;;XMLHttpFactory.prototype = &#123;// 如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类 createFactory:function() &#123; throw new Error(\"This is an abstract class\"); &#125;&#125;var XHRHandler = function() &#123; XMLHttpFactory.call(this);&#125;;XHRHandler.prototype = new XMLHttpFactory();XHRHandler.prototype.constructor = XHRHandler; // 重新定义 createFactory 方法XHRHandler.prototype.createFactory = function() &#123; var XMLHttp = null; if (window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp;&#125;var AjaxHander = function() &#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); /*...具体操作... */&#125; 抽象工厂只留一个接口，不做具体的事，让别的子类来继承我这个类，然后做它自己的事。 代理模式概念代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。代理模式使得代理对象控制具体对象的引用。代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。 作用和注意事项模式作用： 远程代理（一个对象将不同空间的对象进行局部代理） 虚拟代理（根据需要创建开销很大的对象，如图片预加载） 安全代理（控制真实对象的访问权限） 智能指引（调用对象代理处理另外一些事情，如垃圾回收机制） 注意事项： 不能滥用代理，有时候仅仅是给代码增加复杂度 实例12345678910111213141516171819202122// 代理模式需要三方// 1.买家function buyer() &#123; this.name = \"Davis\";&#125;// 2.中介function agent() &#123;&#125;agent.prototype.sell = function() &#123; new seller(new buyer()).sell(\"50万\")&#125;// 3.卖家 收钱function seller(buyer) &#123; this.buyer_name = buyer.name; this.sell = function(money) &#123; console.log(\"收到了来自\" + this.buyer_name + money + \"人民币\"); // 收到了来自Davis50万人民币 &#125;&#125;(new agent).sell(); 虚拟代理实现图片预加载12345678910111213141516171819202122232425262728293031// 图片加载函数var myImage = (function() &#123; var imgNode = document.createElement(\"img\"); document.body.appendChild(imgNode); return &#123; // 提供一个对外的setSrc接口，外界调用这个接口，可以给该img标签设置src属性 setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 引入代理对象var proxyImage = (function() &#123; var img = new Image; img.onload = function() &#123; // 图片加载完成，正式加载图片 myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; // 图片未被载入时，加载一张提示图片 myImage.setSrc(\"file://c:/loading.png\"); img.src = src; &#125; &#125;&#125;)();// 调用代理对象加载图片proxyImage.setSrc(\"http://images/water.jpg\"); 命令模式概念将请求封装成对象，分离命令接受者和发起者之间的耦合。命令执行之前在执行对象中传入接受者，主要目的相互之间的解耦。简单而言分为三个对象： 发起者：发出调用命令即可，具体如何执行，谁执行并不需要清楚。 接受者：有对应的接口处理不同的命令，至于命令是什么，谁发出的，不用关心。 命令对象：上面讲发起者和接受者分开了，二者之间需要个连接桥梁。这就是命令对象。命令对象接受发送者的调用，然后调用接受者的相应接口。 作用和注意事项模式作用： 将函数的封装、请求、调用结合为一体 调用具体的函数解耦命令对象与接收对象 提高程序模块化的灵活性 注意事项： 不需要借口一致，直接调用函数即可，以免造成浪费 实例场景如下：有个按钮button，点击之后，调用menu对象的refresh方法，输出“刷新”的内容。 12345678910111213141516171819202122232425262728// 发送者var setCommond = function(button, fn) &#123; button.onClick = function() &#123; fn() &#125;&#125;;// 执行命令者var menu = &#123; reFresh: function() &#123; console.log(\"刷新\"); &#125;, add: function() &#123; console.log(\"增加\"); &#125;, delete: function() &#123; console.log(\"删除\"); &#125;&#125;;// 命令对象var commondObj = function(reciver) &#123; return function() &#123; reciver.reFresh(); &#125;&#125;;var commondObj1 = commondObj(menu);setCommond(btn1, commondObj1); 发送者(setCommond)：不关心给哪个button，以及绑定什么事件，只要通过参数传入就好。 命令对象(commondObj):只需要接收到接受者的参数，当发送者发出命令时，执行就好。 接受者(menu):不用关心在哪里被调用被谁调用，只需要按需执行就好了。 策略模式概念定义一系列方法，封装起来使他们可以相互替换。也就是将策略封装在策略类中，当发起请求时管理类将请求委托给对应策略类。 发起者：发出调用命令即可，具体如何执行，谁执行并不需要清楚。 接受者：有对应的接口处理不同的命令，至于命令是什么，谁发出的，不用关心。 命令对象：上面讲发起者和接受者分开了，二者之间需要个连接桥梁。这就是命令对象。命令对象接受发送者的调用，然后调用接受者的相应接口。 作用模式作用： 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。 策略模式中的代码可以复用。 实例假设我们现在有这样一个需求：需要根据form表单元素的不同类型，当点击的时候输出对应的表单元素类型。 123456789101112131415161718192021222324252627 /** * 针对不同情况的策略算法封装在策略类fucs中， * 从调用事件中去除繁琐的if或者switch逻辑判断。达到解耦的目的 * 加入后面再增加‘select’的选项增加对应的方法即可 */ var funcs = &#123; text: function() &#123; console.log('this is text') &#125;, radio: function() &#123; console.log('this is radio') &#125;, checkbox: function() &#123; console.log('this is checkbox') &#125;, default: function() &#123; console.log('this is default') &#125; &#125; var renderDom = function(type) &#123; /** * 只需要根据不同的入参，自行匹配策略类中的接口即可。 */ return (funcs[type] || funcs['default'])() &#125;renderDom('checkbox') 策略对象就是funcs对象，里面的不同属性接口对应的方法就是策略。与逻辑判断分离开，如果有不同的情况的出现，对应的增加属性接口即可。 renderDom方法就是对应的管理类，只需要根据不同的type，去调用funcs不同的方法就ok了。如果type没有对应的接口，那就调用默认的default对应接口。 调用事件，就保持不变。将tyoe类型传过去就好了。 职责链模式概念职责链由多个不同的对象组成，发送者是发送请求的对象，而接收者则是链中那些接收请求并且对其进行处理或传递的对象。请求本身有时候也可以是一个对象，它封装了和操作有关的所有数据，基本实现流程如下： 发送者知道链中的第一个接收者，它向这个接收者发送该请求。 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。 如果没有任何接收者处理请求，那么请求会从链中离开。 实例现有A、B、C、D四个生产线，生产总量为2100，每个生产线的生产量未知且在0~2100(包括0和2100，保证总量为2100即可)，生产完毕后，分6次进行运输，规定每台车辆只能运350，且装满后才能够出发，装车顺序为ABCD,即上一个生产线生产的东西装完后才能够装下一个生产线的东西，要求根据每条生产线的生产量，给出每台车辆的托运安排。 例如： A：100 ， B：1400 ，C：500 ， D：100托运安排：第一辆车： A：100 ， B：250第二辆车： A：0 ， B：350第三辆车： A：0 ， B：350第四辆车： A：0 ， B：350第五辆车： A：0 ， B：100 ，C：250第六辆车： A：0 ， B：0 ， C：250 ，D：100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class WearHouse&#123; constructor(volume,wearHouse)&#123; this.volume=volume; this.wearHouse=wearHouse; this.outString=[]; &#125; next(take)&#123; if(this.wearHouse!=undefined) &#123; this.wearHouse.takeOut(take).forEach((subT) =&gt; &#123; this.outString.push(subT) &#125;) &#125; &#125; takeOut(num)&#123; if(num&gt;this.volume)&#123; num-=this.volume; var temp=this.volume; this.volume=0; this.outString.push(this.print(0,temp)); this.next(num); &#125;else&#123; this.volume-=num; this.outString.push(this.print(this.volume,num)); &#125; var temOut=this.outString; this.outString=[]; return temOut; &#125; print(volumn,takeNum)&#123;&#125; &#125; class WearHouseA extends WearHouse&#123; print(volumn,takeNum)&#123; return ['A',takeNum]; &#125; &#125; class WearHouseB extends WearHouse&#123; print(volumn,takeNum)&#123; return ['B',takeNum]; &#125; &#125; class WearHouseC extends WearHouse&#123; print(volumn,takeNum)&#123; return ['C',takeNum]; &#125; &#125; class WearHouseD extends WearHouse&#123; print(volumn,takeNum)&#123; return ['D',takeNum]; &#125; &#125; var D=new WearHouseD(100,undefined); var C=new WearHouseC(500,D); var B=new WearHouseB(1400,C); var A=new WearHouseA(100,B); var strSet=[]; for(var a=0;a&lt;6;a++)&#123; strSet.push(...A.takeOut(350)); &#125; console.log(strSet); 结束语使用设计模式的是为了提高我们解决问题的效率，不同的设计模式也是针对不同环境的特定方案，不仅仅是单独的某一种设计模式，大多数情况下都是多个模式共存的。切勿为了使用设计模式而强行引入，增加代码复杂度。 学习资源：链接：http://pan.baidu.com/s/1i5BYiGH 密码：3s4v","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengfeidai.github.io/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://pengfeidai.github.io/tags/设计模式/"}]},{"title":"cubic-bezier(贝塞尔曲线)","slug":"cubic-bezier","date":"2017-08-05T08:58:46.000Z","updated":"2020-05-22T12:14:57.000Z","comments":true,"path":"2017/08/05/cubic-bezier/","link":"","permalink":"https://pengfeidai.github.io/2017/08/05/cubic-bezier/","excerpt":"","text":"简介cubic-bezier 又称三次贝塞尔，主要是为 animation 生成速度曲线的函数, CSS3 动画速度的控制通过三次贝塞尔曲线函数实现，定义规则为： cubic-bezier (x1, y1, x2, y2)。 cubic-bezier：http://cubic-bezier.com/ css3中常用的几个动画效果： 12345ease: cubic-bezier(0.25, 0.1, 0.25, 1.0) // 开始和结束慢，中间快linear: cubic-bezier(0.0, 0.0, 1.0, 1.0) // 匀速ease-in: cubic-bezier(0.42, 0, 1.0, 1.0) // 开始慢ease-out: cubic-bezier(0, 0, 0.58, 1.0) // 结速慢ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0) // 与ease类似，但比ease幅度大 基本原理贝塞尔曲线通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形，绘制出一条光滑曲线并以曲线的状态来反映动画过程中速度的变化。 image 从上图我们知道的是 cubic-bezier 的取值范围: A：默认值 (0, 0) B：动态取值 (x1, y1) C：动态取值 (x2, y2) D：默认值 (1, 1) 其中 X 轴的取值范围是 [0, 1]，当取值超出范围时 cubic-bezier 将失效；Y 轴的取值没有规定，当然也毋须超过 [0, 1] 过大。 我们需要关注的是 B 和 C 两点的取值，这两点就是所要动态操控的两个点了,对应cubic-bezier (x1,y1,x2,y2)中的四个参数。 实例演示下面用一个简单的实例来看看效果：demo演示 html 部分12&lt;div class=\"normal\"&gt;&lt;/div&gt;&lt;div class=\"custom\"&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233.normal &#123; margin-bottom: 10px; width: 50px; height: 50px; background-color: #ff0000; border-radius: 50%; -webkit-transition: all 2s; -moz-transition: all 2s; -o-transition: all 2s; transition: all 2s;&#125;.normal:hover &#123; -webkit-transform: translateX(150px); -moz-transform: translateX(150px); -o-transform: translateX(150px); transform: translateX(150px);&#125;.custom &#123; width: 50px; height: 50px; border-radius: 50%; background-color: blue; -webkit-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); -moz-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); -o-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); transition: all 2s cubic-bezier(.94,-0.25,.32,1.31);&#125;.custom:hover &#123; -webkit-transform: translateX(300px); -moz-transform: translateX(300px); -o-transform: translateX(300px); transform: translateX(300px);&#125; 红色小球采用默认的速度曲线是 ease，蓝色小球采用自定义cubic-bezier(.94,-0.25,.32,1.31),呈现蓄力加速效果。 transition（过渡）transition属性 transition-property: 过渡属性(默认值为all) transition-duration: 过渡持续时间(默认值为0s) transiton-timing-function: 过渡函数(默认值为ease函数) transition-delay: 过渡延迟时间(默认值为0s) 语法1transition: property duration timing-function delay; animation（动画）animation属性结合@ keyframes使用，animation中的animation-name需要设置成@ keyframes的name一致。例如： 12345678910111213141516171819202122232425262728293031&lt;style&gt;.box &#123; height: 100px; width: 100px; border: 15px solid black; animation: changebox 10s ease-in-out 3 alternate paused;&#125;.box:hover &#123; animation-play-state: running;&#125;@keyframes changebox &#123; 10% &#123; background: red; &#125; 50% &#123; width: 80px; &#125; 70% &#123; border: 15px solid yellow; &#125; 100% &#123; width: 180px; height: 180px; &#125;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; animation属性 animation-name: 指定要绑定到选择器的关键帧的名称 animation-duration: 动画指定需要多少秒或毫秒完成 animation-timing-function: 设置动画将如何完成一个周期 animation-delay: 设置动画在启动前的延迟间隔 animation-iteration-count: 定义动画的播放次数 animation-direction: 指定是否应该轮流反向播放动画 animation-fill-mode:规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式 animation-play-state: 指定动画是否正在运行或已暂停。语法 1animation: name duration timing-function delay iteration-count direction fill-mode play-state; transform（变形）transform 分为2D 和 3D，其主要包含以下几种变换：translate位移，scale缩放，rotate旋转，skew扭曲等。 2D变形： translate位移123transform: translate(50px, 100px);transform: translateX(50px); // x方向移动50pxtransform: translateY(100px); scale缩放123transform: scale(2, .5);transform: scaleX(2); // x方向增加一倍transform: scaleY(.5); // y方向缩小一倍 rotate旋转：rotate（正数表示顺时针旋转，负数表示逆时针旋转）1transform: rotate(30deg); skew扭曲123transform: skew(30deg, 30deg);transform: skewX(30deg);transform: skewY(30deg); 3D变形： translate位移： translate(x, y, z); scale缩放： scale(x, y, z); rotate旋转：rotate3d(x, y, z, angle) (angle:表示3D舞台上旋转的角度)","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://pengfeidai.github.io/tags/CSS3/"}]},{"title":"深入理解Javascript面向对象","slug":"JS面向对象编程","date":"2017-07-28T06:52:56.000Z","updated":"2017-08-21T02:54:00.000Z","comments":true,"path":"2017/07/28/JS面向对象编程/","link":"","permalink":"https://pengfeidai.github.io/2017/07/28/JS面向对象编程/","excerpt":"","text":"简介JavaScript 是一门基于对象的编程语言，在 JavaScript 中一切都是对象，包括函数，也是被当成第一等的对象对待，这正是 JavaScript 极其富有表现力的原因。 理解对象ECMA-262 关于对象的定义是：“无序属性的集合，其属性可以包含基本值、对象或者函数。” 严格说，对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 早期，创建对象就是创建一个 Object的实例，并为它添加属性( name、age )和方法( sayName() )，可以这么写： 123456var person = new Object();person.name = \"Davis\";person.age = 22;person.sayName = function () &#123; alert(this.name);&#125; 现在，对象字面量成为创建对象的首选模式，可以这么写： 12345678var person = &#123; name = \"Davis\", age: 22, sayName: function () &#123; alert(this.name); &#125;&#125;; 这两个例子中 person 对象事一样的，有相同的属性和方法。这些属性在创建时都有一些特征值(characteristic),JavaScript 通过这些特征值来定义他们的行为。 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 数据属性数据属性包含一个数据值的位置，在这个位置可以读取和写入值，具有如下4个特性： [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为 true。[[Enumerable]]: 表示能否通过for-in循环返回属性。直接在对象上定义的属性，默认为true。[[Writable]]: 表示能否修改属性的值。直接在对象上定义的属性，默认为true。[[Value]]: 包含这个属性的数据值；读取属性值的时候，从这个位置读取；写入属性值的时候，把值保存在这里。这个特性默认为undefined 要修改数据属性默认的特性，必须使用ECMAScript5中的Object.defineProperty()方法；接受三个参数：属性所在的对象、属性的名字、描述符对象；其中，数据属性描述符对象的属性必须是：configurable、enumerable、writable和value。12345678var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Davis&quot;&#125;);alert(person.name); //&quot;Davis&quot;person.name = &quot;XX&quot;;alert(person.name); //&quot;Davis&quot; 访问器属性访问器属性包含一对 getter 和 setter 函数。在读取访问器属性时，会调用 getter 函数，负责返回有效的值；在写入时，会调用 setter 函数并传入新值,负责决定如何处理数据。具有如下4个特性： [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为 true。[[Enumerable]]: 表示能否通过for-in循环返回属性。直接在对象上定义的属性，默认为true。[[Get]]: 在读取属性时调用的函数；默认值为undefined。在读取访问器属性时，会调用gette方法，这个函数负责返回有效的值。[[Set]]: 在写入属性时调用的函数；默认值为undefined。在写入访问器属性时，会调用setter方法并传入新值，这个函数负责决定如何处理数据。 访问器属性不能直接定义，必须使用Object.defineProperty()方法来定义。123456789101112131415161718var book = &#123; _year: 2016, edition: 5&#125;;Object.defineProperty(book, \"year\", &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125;&#125;);book.year = 2017;alert(book.edition); // 6 定义多个属性Object.defineProperties()方法，通过描述符一次性定义多个属性； 接收两个对象参数：第一个对象是要添加或修改其属性的对象；第二个对象的属性与第一个对象中要添加或修改的属性一一对应。1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2016 &#125;, edition: &#123; writable: true, value: 5 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125; &#125;&#125;); 以上代码在 book 对象上定义了两个数据属性( _year 和 edition )和一个访问器属性( year )。 读取属性的特性Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符； 接收两个参数：属性所在的对象，要读取其描述符的属性名称。 返回值是一个对象；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value；如果是访问器属性，这个对象的属性有configurable、enumerable、get、set。12345678910111213141516171819202122232425262728293031var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 5 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125; &#125;&#125;);var d = Object.getOwnPropertyDescriptor(book, \"_year\");alert(d.value); // 2016alert(d.configurable); // falsealert(type d.get); // \"undefined\"var d = Object.getOwnPropertyDescriptor(book, \"year\");alert(d.value); // undefinedalert(d.enumerable); // falsealert(type d.get); // \"function\" 对于数据属性_year, value 等于最初的值，configurable 是false，而 get 等于 undefined。 对于访问属性 year，value 等于 undefined，enumerable 是 false，而 get 是指向 getter函数的指针。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengfeidai.github.io/tags/Javascript/"},{"name":"oop","slug":"oop","permalink":"https://pengfeidai.github.io/tags/oop/"}]},{"title":"Vue实现轮播图组件","slug":"Vue-Carousel","date":"2017-07-22T13:37:50.000Z","updated":"2020-05-22T12:14:57.000Z","comments":true,"path":"2017/07/22/Vue-Carousel/","link":"","permalink":"https://pengfeidai.github.io/2017/07/22/Vue-Carousel/","excerpt":"","text":"简介最近在学习 Vue，看到大多数项目首页都有轮播效果，然后自己也是做了一个轮播图，希望分享给大家。 主要技术 v-if: 条件渲染 v-for：列表渲染 v-bind：属性绑定 transition: 过渡效果 组件交互: 父组件通过 props 将数据传递给子组件 主要思路轮播图中，它显示的那张图片在浏览器中可以看到有dom元素。隐藏的是没有dom元素的。所以如果显示一张图片，实际上，轮播列表中只有一个元素是存在的，其他的都被删掉了。按照这个思路，就很简单了。想要轮播，设置：enter：右边→enter-to：正常位置，并且过渡完成→leave：正常位置→leave-to：左边，并且过渡完成。 在线预览👉http://https://pengfeidai.github.io/Carousel/ 源代码项目源码：👉https://github.com/pengfeidai/Carousel","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://pengfeidai.github.io/tags/Vue/"},{"name":"Carousel","slug":"Carousel","permalink":"https://pengfeidai.github.io/tags/Carousel/"}]},{"title":"ES6编码风格","slug":"ES6编码风格","date":"2017-07-20T14:18:06.000Z","updated":"2017-09-26T02:35:16.000Z","comments":true,"path":"2017/07/20/ES6编码风格/","link":"","permalink":"https://pengfeidai.github.io/2017/07/20/ES6编码风格/","excerpt":"","text":"块级作用域let 取代 varES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。123456&apos;use strict&apos;;if(true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。所以，建议不再使用var命令，而是使用let命令取代。 全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。1$ npm i -g eslint 然后，安装Airbnb语法规则。1$ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用ESLint检查这个文件。1234567$ eslint index.jsindex.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 解决浏览器兼容ES6特性使用 babel 转换工具： https://babeljs.io/","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengfeidai.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://pengfeidai.github.io/tags/ES6/"}]},{"title":"ES6，你真的知道吗","slug":"浅谈ES6核心内容","date":"2017-07-16T14:33:25.000Z","updated":"2020-05-25T17:08:27.000Z","comments":true,"path":"2017/07/16/浅谈ES6核心内容/","link":"","permalink":"https://pengfeidai.github.io/2017/07/16/浅谈ES6核心内容/","excerpt":"","text":"ES6简介ECMAScript6（简称ES6）是 JavaScript 语言的下一代标准。在2015年6月正式发布，所以又称ES2015。由于目前并不是所有浏览器都能兼容 ES6 全部特性，但是 ES6 在实际项目中的广泛使用已成为一种趋势。所以作为一个前端开发者，ES6 的语法是我们必须掌握的。 在讲解 ES6 语法之前，我们得先了解下Babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。可在Babel官网 (http://babeljs.io/) 查看： image 使用Gulp 和 Babel 将 ES6 代码转换成 ES5 代码具体过程如下： 安装依赖 安装全局 Gulp 1npm install -g gulp 安装项目中使用的 Gulp 1npm install --save-dev gulp 安装 Gulp 上 Babel 的插件 1npm install --save-dev gulp-babel 安装 Babel 上将 ES6 转换成 ES5 的插件 1npm install --save-dev babel-preset-es2015 Gulp 配置 gulpfile.js 的内容 12345678var gulp = require(\"gulp\");var babel = require(\"gulp-babel\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/**/*.js\") // ES6 源码存放的路径 .pipe(babel()) .pipe(gulp.dest(\"dist\")); //转换成 ES5 存放的路径&#125;); 如果要生成 Soucemap， 则用 gulp-sourcemaps 12345678910111213var gulp = require(\"gulp\");var sourcemaps = require(\"gulp-sourcemaps\");var babel = require(\"gulp-babel\");var concat = require(\"gulp-concat\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/**/*.js\") .pipe(sourcemaps.init()) .pipe(babel()) .pipe(concat(\"all.js\")) .pipe(sourcemaps.write(\".\")) .pipe(gulp.dest(\"dist\"));&#125;); Babel 配置在项目根路径创建文件 .babelrc。内容为：123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; 执行转换命令行中执行1gulp ES6常用特性let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments 这些是ES6最常用的几个语法，基本上学会它们，就可以满足我们日常的使用！下面就用用最通俗易懂的语言和例子来讲解它们。 let 与 const这两个的用途与var类似，都是用来声明变量的，但在实际运用中都有各自的特殊用途。 ES5只有全局作用域、函数作用域和eval作用域，没有块级作用域，这带来很多不合理的场景。 第一种，变量提升：就是var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部；不在函数内即在全局作用域的最顶部。这样就会引起一些误解。1234567console.log(a); // undefinedvar a = 3;// 等价于var a;console.log(a);a = 3; 而 let 就不会被变量提升12console.log(a); // a is not definedlet a = 3; 第二种场景就是内层变量覆盖外层变量。例如：123456789var name = 'Faker'while (true) &#123; var name = 'Davis' console.log(name) //Davis break&#125;console.log(name) //Davis 而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。123456789let name = 'Faker'while (true) &#123; let name = 'Davis' console.log(name) //Davis break&#125;console.log(name) //Faker 第三种场景就是用来计数的循环变量泄露为全局变量，例如：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用 let 则不会出现这个问题。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。123const PI = 3.1415926;PI = 8;console.log(PI); // invalid assignment to const `PI' 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require('moment') Set 和 Map 数据结构与 Array 增、删、改、查对比12345678910111213141516171819202122232425262728293031let map = new Map();let set = new Set();let array = [];// 增map.set('t', 1);set.add( &#123; t : 1 &#125; );array.push( &#123; t:1 &#125; );console.info( map, set, array ); // Map &#123; 't' =&gt; 1 &#125; Set &#123; &#123; t: 1 &#125; &#125; [ &#123; t: 1 &#125; ]// 查let map_exist = map.has( 't' );let set_exist = set.has( &#123;t:1&#125; );let array_exist = array.find(item =&gt; item.t)console.info(map_exist, set_exist, array_exist); //true false &#123; t: 1 &#125;// 改map.set('t', 2);set.forEach(item =&gt; item.t ? item.t = 2:'');array.forEach(item =&gt; item.t ? item.t = 2:'');console.info(map, set, array); // Map &#123; 't' =&gt; 2 &#125; Set &#123; &#123; t: 2 &#125; &#125; [ &#123; t: 2 &#125; ]// 删map.delete('t');set.forEach(item =&gt; item.t ? set.delete(item):'');let index = array.findIndex(item =&gt; item.t);array.splice(index,1);console.info(map, set, array); // Map &#123;&#125; Set &#123;&#125; [] class、extends、superES5中原型、构造函数，继承问题一直困扰我们。ES6引入了Class（类）的概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。123456789101112131415161718192021222324class Human &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(this.name + \" is sleeping\"); &#125;&#125;let man = new Human(\"Davis\");man.sleep(); //Davis is sleepingclass Boy extends Human &#123; constructor(name, age) &#123; super() this.name = name; this.age = age; &#125; info()&#123; console.log(this.name + 'is ' + this.age + 'years old'); &#125;&#125;let son = new Boy('Faker','8');son.sleep(); // Faker is sleepingson.info(); // Faker is 8 years old 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Boy类，该类通过extends关键字，继承了Human类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function 箭头函数ES6中新增的箭头操作符 =&gt; 简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，可以说是 ES6 最最常用的一个新特性了，看下面的实例：1234567891011// ES5let arr = [1, 3, 5, 7, 9];arr.forEach (function(val, key) &#123; return console.log(val, key);&#125;);// ES6let arr = [1, 3, 5, 7, 9];arr.forEach ((val, key) =&gt; console.log(val, key)); JavaScript语言的this对象指向是一个头疼的问题，在对象方法中使用this，必须非常小心。123456789101112class Human &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; setTimeout(function()&#123; console.log(this.name + \" is sleeping\"); &#125;, 1000) &#125;&#125;let man = new Human(\"Davis\");man.sleep(); // is sleeping 上面代码之所以不能输出 Davis，这是因为setTimeout中的this指向的是全局对象。为了让它能够正确的运行，传统的解决方法有两种：123456789101112// 第一种，将this传给self,再用self来指代thissleep() &#123; var self = this; setTimeout(function()&#123; console.log(self.name + \" is sleeping\"); &#125;, 1000)// 第二种，是用bind(this)sleep() &#123; setTimeout(function()&#123; console.log(self.name + \" is sleeping\") &#125;.bind(this), 1000) 使用箭头函数，非常方便：123456789101112class Human &#123; constructor(name)&#123; this.name = name; &#125; sleep() &#123; setTimeout( () =&gt; &#123; console.log(this.name + \"is sleeping\"); &#125;, 1000) &#125;&#125;let man = new Human(\"Davis\");man.sleep(); // Davis is sleeping 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string 模板字符串ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。12let num = Math.random();console.log(` num is $&#123;num&#125;`); // num is xx 不再通过 \\ 来做多行字符串拼接，模板字符串可以多行书写：1234$(\"#main\").html(` &lt;h1&gt;今天天气很好！&lt;/h1&gt; &lt;p&gt;产生一个随机数$&#123;num&#125;&lt;/p&gt;`); 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 destructuring 解构ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 用途一，交换变量的值，不再需要中间变量1234let a = 1;let b = 2;[a, b] = [b, a];console.log(a, b); // 2 1 用途二，提取JSON数据123456789let jsonData = &#123; id: 1, title: \"OK\", data: [5, 6]&#125;;let &#123;id, title, data:number&#125; = jsonData;console.log(id, title, number); // 1, \"OK\", [5, 6] 用途三，函数参数的定义1234567891011 // 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123;...&#125;f(&#123;z: 3, y: 2, x: 1&#125;); default默认参数default很简单，就是默认值。现在可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。1234567891011121314// 传统指定默认参数function say1(name) &#123; var name = name || 'Faker'; console.log( 'Hello ' + name );&#125;// ES6默认参数function say2(name='Davis') &#123; console.log(`Hello $&#123;name&#125;`);&#125;say1(); // Hello Fakersay1('Tom'); // Hello tomsay2(); //Hello Davissay2('Bob'); // Hello Bob 注意： say2(name=’tom’)这里的等号，指的是没有传这个参数，则设置默认值Davis，而不是给参数赋值。 rest参数rest参数只包括那些没有给出名称的参数； rest参数是Array的实例，可以直接应用sort, map, forEach, pop等方法； rest参数之后不能再有其它参数（即，只能是最后一个参数）； 函数的length属性，不包括rest参数；12345function fn(x, y, ...rest)&#123; console.log(rest)&#125;fn(1, \"cat\", \"dog\", 2); //[\"dog\", 2]console.log(fn.length); //2 Proxy 代理Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。1234567891011121314//定义被监听的目标对象let man = &#123; name: 'Davis', age: 21 &#125;;//定义处理程序let handle = &#123; set(receiver, property, value) &#123; console.log(property, 'is changed to', value); receiver[property] = value; &#125;&#125;;//创建代理以进行侦听man = new Proxy(man, handle);//做一些改动来触发代理man.age = 22; //age is change to 22man.name = \"Faker\"; // name is change to Faker PromisePromise对象状态 Promise/A+规范, 规定Promise对象是一个有限状态机。它三个状态： pending（执行中） Resolved（已完成） Rejected（已失败） 其中pending为初始状态，Resolved和rejected为结束状态（表示promise的生命周期已结束）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let val = 1;// 我们假设step1, step2, step3都是ajax调用后端或者是在Node.js上查询数据库的异步操作// 每个步骤都有对应的失败和成功处理回调// step1、step2、step3必须按顺序执行function step1(resolve, reject) &#123; console.log('步骤一：执行'); if (val &gt;= 1) &#123; resolve('Hello I am No.1'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;function step2(resolve, reject) &#123; console.log('步骤二：执行'); if (val === 1) &#123; resolve('Hello I am No.2'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;function step3(resolve, reject) &#123; console.log('步骤三：执行'); if (val === 1) &#123; resolve('Hello I am No.3'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;new Promise(step1).then(function(val)&#123; console.info(val); return new Promise(step2);&#125;).then(function(val)&#123; console.info(val); return new Promise(step3);&#125;).then(function(val)&#123; console.info(val); return val;&#125;).then(function(val)&#123; console.info(val); return val;&#125;);// 执行之后将会打印步骤一：执行Hello I am No.1步骤二：执行Hello I am No.2步骤三：执行Hello I am No.3Hello I am No.3 常用关键点： 在Promise定义时，函数已经执行了；Promise构造函数只接受一个参数，即带有异步逻辑的函数。这个函数在 new Promise 时已经执行了。只不过在没有调用 then 之前不会 resolve 或 reject。 在then方法中通常传递两个参数，一个 resolve 函数，一个 reject 函数。reject就是出错的时候运行的函数。resolve 函数必须返回一个值才能把链式调用进行下去。 resolve 返回一个新 Promise返回一个新Promise之后再调用的then就是新Promise中的逻辑了。 resolve 返回一个值返回一个值会传递到下一个then的resolve方法参数中。 GeneratorGenerator函数跟普通函数的写法有非常大的区别： function关键字与函数名之间有一个 *； 函数体内部使用yield语句，定义不同的内部状态； 123456789101112function* f() &#123; yield 'a'; yield 'b'; yield 'c'; return 'ending';&#125;let fn = f();console.log(fn.next()); // &#123; value: 'a', done: false &#125;console.log(fn.next()); // &#123; value: 'b', done: false &#125;console.log(fn.next()); // &#123; value: 'c', done: false &#125;console.log(fn.next()); // &#123; value: 'ending', done: true &#125; 第一次输出fn.next()返回一个简单的对象{value: “a”, done: false}，’a’就是f函数执行到第一个yield语句之后得到的值，false表示f函数还没有执行完，只是在这暂停。 第二次，返回的就是{value: “b”, done: false}，说明f函数运行到了第二个yield语句，返回的是该yield语句的返回值’b’。返回之后依然是暂停。 第三次，第四次同理，这样整个f函数就运行完毕了。 异步操作的同步化写法Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 例子：假设我在测试服务器的某目录建了4个文件，分别是’test.html’、’a.html’、’b.html’、’c.html’，后三个文件的文件内容跟文件名相同，现在我编辑’test.html’的代码，想要先ajax-get相对网址’a.html’，然后再回调里ajax-get相对网址’b.html’，然后在回调里ajax-get相对网址’c.html’。 12345678910111213141516171819function req(url) &#123; $.get(url, function(res)&#123; it.next(res); &#125;);&#125;// 生成器函数function* ajaxs() &#123; console.log(yield req('a.html')); console.log(yield req('b.html')); console.log(yield req('c.html'));&#125;var it = ajaxs(); // 遍历器对象it.next();// a.html// b.html// c.html 强调：只有当yield后面跟的函数先执行完，无论执行体里面有多少异步回调，都要等所有回调先执行完，才会执行等号赋值，以及再后面的操作。这也是yield最大的特性。 export、importexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口； import用于在一个模块中加载另一个含有export接口的模块。 导出一组对象 导出模块文件app.js：123456789101112131415class Human&#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(this.name + &quot; is sleeping&quot;); &#125;&#125;function walk() &#123; console.log(&apos;i am walking&apos;);&#125;function play() &#123; console.log(&apos;i am playing&apos;);&#125;export &#123; Human, walk &#125; 模块导出了两个对象：Human类和walk函数，能被其他文件使用。而play函数没有导出，为此模块私有，不能被其他文件使用。 main.js导入app.js模块1import &#123; Human, walk &#125; from &apos;app.js&apos;; Default导出使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。12... //类，函数等export default App; main.js导入app.js模块1import App from &apos;app.js&apos;; 结语以上这些是ES6最常用的几个语法，基本上学会它们，就可以满足我们日常的使用！ES6的新语法特性让前端和后端的差异越来越小了，我们必须要了解这些新的前沿知识（虽然ES8已经到来，但我相信目前还是ES6的时代），才能更好运用于项目中。 项目源码：https://github.com/pengfeidai/lottery-es6","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pengfeidai.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://pengfeidai.github.io/tags/ES6/"},{"name":"gulp","slug":"gulp","permalink":"https://pengfeidai.github.io/tags/gulp/"}]},{"title":"响应式网页开发你不知道的那些事","slug":"响应式网页开发应注意的那些事儿","date":"2017-07-11T14:52:28.000Z","updated":"2020-05-22T12:14:57.000Z","comments":true,"path":"2017/07/11/响应式网页开发应注意的那些事儿/","link":"","permalink":"https://pengfeidai.github.io/2017/07/11/响应式网页开发应注意的那些事儿/","excerpt":"","text":"简介响应式网页设计通过使用弹性网格和布局、响应式图片、CSS media query等技术手段，使页面能够自动切换分辨率、图片尺寸及相关脚本功能，以适应不同设备，来满足用户在各种设备环境下的需求。响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。 image 媒体查询什么是媒体查询媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 如何在CSS文件中引入媒体查询媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式。 怎样使用media第一步：需要在html文档中添加以下代码，用来兼容移动设备的显示效果1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; width=device-width:宽度等于当前设备的宽度 initial-scale=1：初始的缩放比例（默认为1） minimum-scale=1：允许用户缩放到得最小比例（默认为1） maximum-scale=1：允许用户缩放到得最大比例（默认为1） user-scalable=no：用户不能手动缩放 第二步：怎样在CSS文件中写CSS响应式媒体查询1234567891011121314151617181920body &#123; font-size: 1.6rem; background: #f7f7f7;&#125;@media only screen and (max-width: 50em) &#123; body &#123; font-size: 1.2rem; background: #fff; &#125;&#125;@media only screen and (min-width: 30.0625em) and (max-width:50em)&#123;&#125;@media only screen and (max-width: 30em) &#123; body &#123; font-size: 1.0rem; background: #999; &#125;&#125; 在不同宽度下，改变背景颜色和字体大小 兼容性解决部分IE浏览器(IE9以下)，不支持 html5 和媒体查询。需要在 html 文档 &lt;head&gt;&lt;/head&gt;标签中添加以下代码。1234&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; html5shiv：解决IE浏览器(IE6、IE7、IE8)不支持HTML5的问题respond：使IE浏览器(IE6、IE7、IE8)支持媒体查询中的min-width和max-width 相对长度单位px: 像素，1个px相当于一个像素 em: 元素字体高度，相对参照物为父元素的 font-size。em 的值并不固定，会继承父元素的字体大小 rem: 元素字体高度，相对参照物为根元素 html,相于参照固定不变。目前，除 IE9 以下版本，所有浏览器均已支持rem 注意： 若rem没有在根元素（html字体）指定参照值，那浏览器默认1 rem就是16px,若rem有指定值，则1rem就是等于指定值 。 html设置为62.5%或者10px时会失效，是因为小于12px或者75%的字体大小不支持换算。这可能与有些浏览器不支持12px以下的大小有关。所以，使用rem单位，html的字体默认字体大小必须设置为12px或以上。若小于12px则浏览器换算时自动默认字体为12px。123456html &#123; font-size: 62.5%; /* 10÷16=62.5% */&#125;body &#123; font-size:1.2rem ; /* 12÷10=1.2 */&#125; 在响应式网页开发中，我们会更多的使用到 rem，而对 px的适应基本很少。 响应式广告现在大部分的网页都会有一个滚动广告(轮播图)，一个好的广告滚动组件支持： 支持不同的图片数量 支持响应式 具有良好的兼容性 现在网上滚动广告组件非常多，在这里我只推荐两种 Owl Carousel 2和 myfocus，非常轻量，使用文档非常齐全。这里，主要讲一下 Owl Carousel 2的用法。 Owl Carousel 2 下载之后的目录结构： 1234567891011121314Owlcarousel2/├── assets/│ ├── owl.carousel.css│ ├── owl.carousel.min.css // 主样式文件│ ├── owl.theme.default.css│ ├── owl.theme.default.min.css // 皮肤样式文件│ ├── owl.theme.green.css│ ├── owl.theme.green.min.css│ └── owl.video.play.png│├── owl.carousel.js├── owl.carousel.min.js├── LICENSE-MIT└── README.md html结构：12345678910111213&lt;div class=&quot;ad&quot;&gt; &lt;div class=&quot;owl-carousel owl-theme&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad001.png&quot; alt=&quot;&quot;&gt; // 图片尺寸480*480 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad002.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad003.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在html文件中引入css:12&lt;link rel=&quot;stylesheet&quot; href=&quot;OwlCarousel2/assets/owl.carousel.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;OwlCarousel2/assets/owl.theme.default.min.css&quot;&gt; 在html文件中引入js:123&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;OwlCarousel2/owl.carousel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt; main文件自己定义：123456789$(document).ready(function()&#123; $(&quot;.owl-carousel&quot;).owlCarousel(&#123; items: 1, // 一屏看到的图片数量 loop: true, // 循环滚动 autoplay: true, // 自动播放 autoplayTimeout: 3000, // 时间间隔 autoplayHoverPause: true //鼠标放在图片上暂停滚动 &#125;);&#125;); 当然现在滚动效果就已经完成了。不过还有一个问题，当屏幕尺寸放大或缩小时，始终都是480尺寸的图片，看起来就是不爽，那么如何能实现让图片在不同设备下自动切换成我们想要的尺寸呢？那么下面就需要用到响应式图片~ 响应式图片js和服务端控制提前在图片库准备三张480、800、1600尺寸的图片。1234567891011121314$(function()&#123; function makeImageResponsive()&#123; var img = $(&apos;.cotent img&apos;); var width = $(window).width(); if(width &lt;= 480)&#123; img.attr(&apos;src&apos;, &apos;480.png&apos;); &#125;else if(width &lt;= 800)&#123; img.attr(&apos;src&apos;, &apos;800.png&apos;); &#125;else&#123; img.attr(&apos;src&apos;, &apos;1600.png&apos;); &#125; &#125;$(window).on(&apos;resize load&apos;, makeImageResponsive);&#125;) srcset属性通过 srcset 指定给 标签所有图片源的信息。然后使用逗号分隔列出一个从小到大的图片源列表。每个图片源后可以跟w描述符或者x描述符1&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w,img/800.png 800w, img/1600.png 1600w alt=&quot;&quot;&gt; 如果浏览器支持 srcset 则会根据屏幕宽度采用最佳的图片，否则直接下载 src 属性内的图像。 picture属性picture是html5新属性，可以放置多个source标签，以指定不同的图像文件名，进而根据不同的条件进行加载。由于现在很多浏览器对于picture这个标签还不支持，所以我们需要引用picturefill.js来解决。 1234567891011121314151617181920212223242526 &lt;div class=&quot;owl-carousel owl-theme&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad001-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad001-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad001.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad002-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad002-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad002.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad003-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad003-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad003.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 在 body 末尾引入--&gt;&lt;script src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt; 在大于800px的时候，展示ad00x-l这个large图片。在大于480px的时候，展示ad00x-m这个medium图片。否则，展示ad00x小图片。完美解决图片响应式问题，极力推荐这种方法。 打包发布当所有的代码完成之后，我们的网站就可以发布了，在发布之前我们还可以对代码进行优化： 压缩 合并 增加版本号 在线压缩:(https://javascript-minifier.com/) 工具打包： Grunt：自动化构建工具 Gulp：自动化构建工具 Webpack:静态资源打包工具 3个主流工具我就不详细一 一介绍了。这里，主要使用 gulp 来打包发布，首先来安装gulp。 第一步：安装Nodejs 在 Node.js 官网：https://nodejs.org/en/ 下载安装包 保持默认设置即可，一路Next，安装很快就结束了。 然后打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！ 第二步：安装Git 在 Git 官网：https://git-scm.com/ 下载安装包 安装完成后，桌面右键，打开 Git Bush Here，输入 git --version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ 第三步：安装Gulp(全局) 桌面右键，打开 Git Bush Here，输入npm install gulp -g 安装完成后，同样输入 gulp -v，出现版本号则说明，则说明安装成功。 第四步：作为项目的开发依赖（devDependencies）安装1$ npm install --save-dev gulp 第五步：在项目根目录下创建一个名为 gulpfile.js 的文件，并且新建一个 dist 文件夹，用于存放压缩后的文件123456789101112131415161718192021222324252627var gulp = require(&apos;gulp&apos;);var rev = require(&apos;gulp-rev&apos;);var revReplace = require(&apos;gulp-rev-replace&apos;);var useref = require(&apos;gulp-useref&apos;);var filter = require(&apos;gulp-filter&apos;);var uglify = require(&apos;gulp-uglify&apos;);var csso = require(&apos;gulp-csso&apos;);gulp.task(&apos;default&apos;, function() &#123; var jsFilter = filter(&apos;**/*.js&apos;, &#123;restore: true&#125;); var cssFilter = filter(&apos;**/*.css&apos;, &#123;restore: true&#125;); var indexHtmlFilter = filter([&apos;**/*&apos;, &apos;!**/index.html&apos;], &#123;restore: true&#125;); return gulp.src(&apos;src/index.html&apos;) .pipe(useref()) .pipe(jsFilter) .pipe(uglify()) .pipe(jsFilter.restore) .pipe(cssFilter) .pipe(csso()) .pipe(cssFilter.restore) .pipe(indexHtmlFilter) .pipe(rev()) .pipe(indexHtmlFilter.restore) .pipe(revReplace()) .pipe(gulp.dest(&apos;dist&apos;));&#125;); 第六步：安装以上需要的gulp插件：1$ npm install gulp gulp-rev gulp-rev-replace gulp-useref gulp-filter gulp-filter gulp-uglify gulp-csso --save-dev 第七步：将 htlm 中需要打包合并的文件添加注释1234567891011121314&lt;!-- build:css css/combined.css --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;js/vendor/OwlCarousel2/assets/owl.carousel.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;js/vendor/OwlCarousel2/assets/owl.theme.default.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt;&lt;!-- endbuild --&gt;&lt;!-- build:js js/combined.js --&gt;&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vendor/OwlCarousel2/owl.carousel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 第八步：执行gulp1$ gulp 执行gulp之后，你会在新建的 dist 文件夹中看到打包生成的文件，目录如下：12345678dist/├── css/│ ├──combined-3f8e363e08.css // 打包合并后的css文件│ └──combined-56ca943019.css├── img/├── js/│ └── combined-7762fa2c22.js // 打包合并后的js文件└── index.html 这时候 css, js 文件都被压缩合并成了一个文件，看起来更加轻量。如果你修改了源代码中的内容，只需再次执行gulp ，则会生成另一个心得css或js文件，版本号会更新，不会覆盖之前的文件。如上面生成新的 combined-56ca943019.css 文件，也保留之前的 combined-3f8e363e08.css。 总结本篇文章包含了响应式网站开发中常见的问题及解决方案，希望对热爱前端开发的同学有所帮助，能让你们在以后的响应式开发中少走弯路。 在线演示：http://https://pengfeidai.github.io/responsive-lichaibao/dist/index 项目源码：https://github.com/pengfeidai/responsive-lichaibao","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://pengfeidai.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://pengfeidai.github.io/tags/CSS/"},{"name":"gulp","slug":"gulp","permalink":"https://pengfeidai.github.io/tags/gulp/"},{"name":"响应式网站","slug":"响应式网站","permalink":"https://pengfeidai.github.io/tags/响应式网站/"}]}]}