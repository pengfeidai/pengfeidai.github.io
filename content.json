{"meta":{"title":"Davis' Blog","subtitle":"专注于Golang、Node.js技术","description":"欢迎来到没事放放牛的个人博客！","author":"没事放放牛","url":"http://dpfblog.com"},"pages":[{"title":"","date":"2020-05-22T11:43:39.000Z","updated":"2017-07-17T12:02:42.000Z","comments":true,"path":"404.html","permalink":"http://dpfblog.com/404.html","excerpt":"","text":"没事放放牛—msffn.com | 404 html, body { height: 100%; min-height: 100%; background: #161B20; overflow: hidden } #block { width: 1px; height: 1px; font-size: 10px } #block:after { content: ''; position: absolute; top: 36%; left: 50%; width: 1em; height: 1em; -webkit-transform: translateX(-14em); transform: translateX(-14em) } @media screen and (max-width:320px) { #block:after { -webkit-transform: translateX(-11.5em) scale(.8); transform: translateX(-11.5em) scale(.8) } } .home { position: absolute; bottom: 10%; left: 50%; margin-left: -14px; text-decoration: none } .icon-home { position: relative; display: block; width: 30px; height: 30px; background: #484C4D } .icon-home:before { content: ''; position: absolute; width: 0; height: 0; top: -40px; left: -9px; border: 24px solid transparent; border-bottom-color: #484C4D } .icon-home:after { content: ''; position: absolute; height: 0; width: 0; top: 16px; left: 7px; width: 16px; height: 14px; background: #161B20 } !function() { function n() { return \"#\" + (\"00000\" + (16777215 * Math.random() + .5 >> 0).toString(16)).slice( - 6) } function e(e, t) { return e + \"em \" + t + \"em \" + n() } function t(n, e, t, u) { var r = document.getElementById(n); r || (r = document.createElement(\"style\"), r.id = n), r.innerHTML = e + \"{\" + t + \":\" + u + \";}\", document.getElementsByTagName(\"head\")[0].appendChild(r) } function u(n, t, u, r) { for (var o = [], s = 0, h = t - .5; n + u >= s; s++, h = t - .5 * (s + 1)) if (s === n) for (var i = h + .5; t + r >= i; i++) o.push(e(i, n)); else o.push(e(t, s)), n > s && o.push(e(h, s + .5)); return o.join(\",\") } function r(n, t, u) { for (var r = [], o = 0, s = 0; u > s; s++) r.push(e(n + s, 0)), r.push(e(n + s, t)); for (r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), o = t - 1, r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), s = 1; t > s; s++) r.push(e(n - 1, s)), r.push(e(n + u, s)); return r.join(\",\") } setInterval(function() { t(\"style\", \"#block:after\", \"box-shadow\", u(10, 5, 2, 1) + \",\" + r(12, 12, 5) + \",\" + u(10, 26, 2, 1)) }, 200) } ();"},{"title":"关于我","date":"2017-07-07T13:19:11.000Z","updated":"2017-09-22T06:20:42.000Z","comments":true,"path":"about/index.html","permalink":"http://dpfblog.com/about/index.html","excerpt":"","text":"个人简介 姓名： 戴鹏飞 学校： 长江大学 专业： 软件工程 QQ： 302804389(开始聊天) 邮箱： 302804389@qq.com GitHub： https://github.com/pengfeidai 个人简介： 👉目前是一名专注web前端的大四程序员，求实习(^ ω ^) ! ! ! 技术清单： 【前端】：HTML/HTML5、CSS/CSS3、JavaScript、Ajax、jQuery、Bootstrap、Vue.js、Angular、微信小程序等 【后端】：Node.js、JAVA 【数据库】：MongoDB、SQL Server 【自动化构建工具】：Webpack、gulp"},{"title":"tags","date":"2017-07-07T13:18:56.000Z","updated":"2017-07-08T13:41:16.000Z","comments":false,"path":"tags/index.html","permalink":"http://dpfblog.com/tags/index.html","excerpt":"","text":"您好！"},{"title":"我的作品","date":"2020-05-22T11:43:39.000Z","updated":"2017-09-24T11:46:24.000Z","comments":false,"path":"categories/index.html","permalink":"http://dpfblog.com/categories/index.html","excerpt":"","text":"@timeline{ 详情索引@item{ 2017.05响应式理财网站以一个金融网站为案例，学习响应式网页的制作 } @item{ 2017.06Angular在线竞拍网站使用 Angular4.0 + Nodejs + Express 完成的在线竞拍网站 } @item{ 2017.07移动端音乐 App基于 Vue 全家桶 (2.x) 制作的移动端音乐 WebApp。 } @item{ 2017.08班级博客前端迈向全栈入门篇。基于 Node.js + Express + ejs+ MongoDB + Bootstrap 搭建的班级博客系统。 } }"}],"posts":[{"title":"javascript数组方法总结","slug":"array","date":"2017-09-20T14:02:52.000Z","updated":"2017-09-30T15:18:30.000Z","comments":true,"path":"2017/09/20/array/","link":"","permalink":"http://dpfblog.com/2017/09/20/array/","excerpt":"","text":"数组创建第一种，使用 Array 构造函数：123var arr1 = new Array(); //创建一个空数组var arr2 = new Array(10); // 创建一个包含10项的数组var arr3 = new Array(\"a\", \"b\",\"c\"); // 创建一个包含3个字符串的数组 第二种，使用数组字面量表示法：12var arr1 = []; //创建一个空数组var arr2 = [\"a\", \"b\", \"c\"]; // 创建一个包含3个字符串的数组 在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：1234var arr = [\"a\", \"b\", \"c\"];console.log(arr[0]); // aarr[2] = \"d\"; // 将下标为2的 c 修改为 darr[3] = \"e\"; // 增加第四项为e JavaScript中数组的length属性是可以修改的，看下面的示例：123var arr = [\"a\", \"b\", \"c\"];arr[arr.length] = \"d\"; // 在数组尾部添加一项\"d\"arr.length = arr.length-1; //将最后一项删除 如何判断一个变量是不是数组对象1234567var arr = [];// ES5之前arr instanceof Array;// ES5新增arr.isArray();typeof arr; // object 数组方法join()join()：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [\"a\", \"b\", \"c\"];console.log(arr.join()); // a, b, cconsole.log(arr.join(\"-\")); // a-b-cconsole.log(arr); // [a, b, c]（原数组不变） 应用：通过join()方法可以实现重复字符串。1234function repeatString(str, n) &#123;return new Array(n + 1).join(str);&#125;console.log(repeatString(\"a\", 3)); // aaa push()和pop()push()：可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。1234567var arr = [\"a\", \"b\", \"c\"];var count = arr.push(\"d\", \"e\");console.log(count); // 5console.log(arr); // [\"a\", \"b\", \"c\", \"d\", \"e\"]var item = arr.pop();console.log(item); // econsole.log(arr); // [\"a\", \"b\", \"c\", \"d\"] shift() 和 unshift()shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift()：将参数添加到原数组开头，并返回数组的长度 。1234567var arr = [\"c\", \"d\", \"e\"];var count = arr.unshift(\"a\",\"b\");console.log(count); // 5console.log(arr); // [\"a\", \"b\", \"c\", \"d\", \"e\"]var item = arr.shift();console.log(item); // aconsole.log(arr); // [\"b\", \"c\", \"d\", \"e\"] sort()（原数组改变）sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串。123456var arr1 = [\"a\", \"d\", \"c\", \"b\"];console.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]console.log(arr1); // [\"a\", \"b\", \"c\", \"d\"]var arr2 = [15, 22, 46, 3];console.log(arr2.sort()); // [15, 22, 3, 46]console.log(arr2); // [15, 22, 3, 46] 解决方法：sort()方法可以接收一个比较函数作为参数，比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;arr2 = [15, 22, 46, 3];console.log(arr2.sort(compare)); // [3, 15, 22, 46] 如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可。12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;arr2 = [15, 22, 46, 3];console.log(arr2.sort(compare)); // [46, 22, 15, 3] reverse()（原数组改变）reverse()：反转数组项的顺序。123var arr = [15, 22, 46, 3];console.log(arr.reverse()); // [3, 46, 22, 15]console.log(arr); // [3, 46, 22, 15] concat()concat()：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。1234var arr = [1, 3, 5, 7];var arr1 = arr.concat(9, [11, 13]);console.log(arr1); // [1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7] 若传入的是一个二维数组。123var arr2 = arr.concat([9, [11, 13]]);console.log(arr2); // [1, 3, 5, 7, 9, Array[2]]console.log(arr2[5]); // [11, 13] slice()slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345678910var arr = [1, 3, 5, 7, 9, 11];var arr1 = arr.slice(1);var arr2 = arr.slice(1, 4);var arr3 = arr.slice(1, -2);var arr4 = arr.slice(-4, -1);console.log(arr); // [1, 3, 5, 7, 9, 11]console.log(arr1); // [3, 5, 7, 9, 11]console.log(arr2); // [3, 5, 7]console.log(arr3); // [3, 5, 7]console.log(arr4); // [5, 7, 9] arr1只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。arr2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。arr3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。arr4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2, 5)。 splice()splice()：可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。12345678910var arr = [1, 3, 5, 7, 9, 11];var arr1 = arr.splice(0, 2);console.log(arr); //[5, 7, 9, 11]console.log(arr1); //[1, 3]var arr2 = arr.splice(2, 0, 4, 6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrR2); // []var arr3 = arr.splice(1, 1, 2, 4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrR3); // [7] indexOf()和 lastIndexOf()indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。123456var arr = [1, 3, 5, 7, 7, 5, 3, 1];console.log(arr.indexOf(5)); // 2console.log(arr.lastIndexOf(5)); // 5console.log(arr.indexOf(5,2)); // 2console.log(arr.lastIndexOf(5, 4)); // 2console.log(arr.indexOf(\"5\")); // -1 forEach()forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：值，索引。1234567var arr = [1, 2, 3];arr.forEach(function(item, index)&#123;console.log(index, item);&#125;);// 0, 1// 1, 2// 2, 3 map()map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。下面代码利用map方法实现数组中每个数求平方。12345var arr = [1, 2, 3, 4];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); // [1, 4, 9, 16] filter()filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;);console.log(arr2); //[1, 4, 7, 8, 9, 10] every()every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123; return x &lt; 10;&#125;);console.log(arr2); // truevar arr3 = arr.every(function(x) &#123; return x &lt; 3;&#125;);console.log(arr3); // false some()some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123; return x &lt; 3;&#125;);console.log(arr2); // truevar arr3 = arr.some(function(x) &#123; return x &lt; 1;&#125;);console.log(arr3); // false reduce()和 reduceRight()这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。reduceRight()则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。12345var values = [1, 2, 3, 4, 5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;, 10);console.log(sum); //25","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://dpfblog.com/tags/Javascript/"}]},{"title":"MongoDB学习笔记","slug":"MongoDB","date":"2017-09-10T13:58:21.000Z","updated":"2017-09-27T09:36:54.000Z","comments":true,"path":"2017/09/10/MongoDB/","link":"","permalink":"http://dpfblog.com/2017/09/10/MongoDB/","excerpt":"","text":"简介什么是NoSQL?NoSQL，指的是非关系型的数据库。 没有行、列的概念。用 JSON 来存储数据。集合就相当于 SQL 数据库中的“表”，文档就相当于“行”。 适用于： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 什么是MongoDB?官网：https://www.mongodb.com 手册：https://docs.mongodb.org/manual MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB安装及运行下载最新的stable版：https://www.mongodb.com/download-center#community 安装好之后，我们看一下安装的文件夹，例如：C:\\Program Files\\MongoDB\\Server\\3.0\\bin，将其加入到系统的path环境变量中，那么我们就能在系统的任何盘符，使用mongo命令了。 123mongo 使用数据库mongod 开机mongoimport 导入数据 启动mongod服务 image –dbpath就是选择数据库文档所在的文件夹。 管理数据库（新开一个cmd） image 那么，运行环境就是mongo语法了。 MongoDB常用操作查看所有数据库1show dbs 使用数据库、创建数据库1use test use一个不存在的，就是新建。 查看当前所在数据库1db 插入数据数据库中不能直接插入数据，只能往集合(collections)中插入数据。不需要创建集合，只需要写点语法： 1db.student.insert(&#123;&quot;name&quot;:&quot;Davis&quot;,&quot;age&quot;:&quot;22&quot;,&quot;sex&quot;:&quot;男&quot;&#125;) db.student 系统发现student是一个陌生的集合名字，所以就自动创建了集合。 删除数据库删除当前数据库1db.dropDatabase(); 数据库使用插入数据插入数据，随着数据的插入，数据库创建成功了，集合也创建成功了。 1db.student.insert(&#123;&quot;name&quot;:&quot;Davis&quot;,&quot;age&quot;:&quot;22&quot;,&quot;sex&quot;:&quot;男&quot;&#125;) 我们不可能一条一条的insert。所以，我们希望用sublime在外部写好数据库的形式，然后导入数据库： 导入json1mongoimport --db test --collection student --drop --file data.json 导入json数组1mongoimport --db test --collection student --drop --file data.json --jsonArray -db test 想往哪个数据库里面导入--collection student 想往哪个集合中导入--drop 把已存在数据清空--file data.json 哪个文件 这样，我们就能用sublime创建一个json文件，然后用mongoimport命令导入。 查找数据 查找数据，用find。find中没有参数，那么将列出这个集合的所有文档： 1db.student.find() 精确匹配 1db.student.find(&#123;&quot;age&quot;:22&#125;) 多个条件 1db.student.find(&#123;&quot;age&quot;:12, &quot;sex&quot;:&quot;男&quot;&#125;) 大于条件 1db.student.find(&#123;&quot;age&quot;:&#123;$gt:20&#125;&#125;) 或者（寻找所有年龄是20岁，或者22岁的学生） 1db.student.find(&#123;$or:[&#123;&quot;age&quot;:20&#125;,&#123;&quot;age&quot;:22&#125;]&#125;); 查找完毕之后，打点调用sort，表示升（1）降（-1）排序 1db.student.find().sort(&#123;&quot;age&quot;:1, &quot;score.English&quot;:1&#125;) 查看当前Mongodb运行状态 1db.student.stats(); 分页查询 通过 sike() 与 limit() 方法 假如，第一页是page=0。每页10条，所以当前页的查询语句1db.student.find(&#123;&#125;).limit(10).skip(page*10) limit()表示读取的条数，sike()表示略过的条数。 修改数据 修改里面还有查询条件 查找名字叫做Davis的，把年龄更改为20岁：1db.student.update(&#123;&quot;name&quot;:&quot;Davis&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;) 更改所有匹配项目 1db.student.update(&#123;&quot;sex&quot;:&quot;男&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;,&#123;multi: true&#125;); 完整替换，不出现$set关键字了 1db.student.update(&#123;&quot;name&quot;:&quot;Davis&quot;&#125;,&#123;&quot;name&quot;:&quot;dpf&quot;,&quot;age&quot;:20&#125;); 删除数据 删除集合中高数成绩为 60 的学生 1db.student.remove(&#123;&apos;score.English&apos;:60&#125;); 删除第一条找到的记录可以设置 justOne 为 1 1db.student.remove(&#123;&apos;score.English&apos;:60&#125;,1); MongooseMongoose，是一个将JavaScript对象与数据库产生关系的一个框架，object related model。所有的操作都不是对数据库进行的。而是对类、实例进行的，对象产生了，同时也持久化了。 官网：http://mongoosejs.com/ 数据库连接1234567var mongoose = require('mongoose');//创建数据库连接var db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');//监听open事件db.once('open', function (callback) &#123; console.log(\"数据库成功连接\");&#125;); 定义模型 image 创造schema → 定义一些schema的静态方法 → 创造模型 创造schema1new mongoose.schema(&#123;&#125;); 创造模型1db.model(“Student”,schema名字); 1234567891011121314151617//创建了一个schema结构。var studentSchema = new mongoose.Schema(&#123; name : &#123;type : String&#125;, age : &#123;type : Number&#125;, sex : &#123;type : String&#125;&#125;);//创建静态方法studentSchema.statics.zhaoren = function(name, callback) &#123; this.model('Student').find(&#123;name: name&#125;, callback); //this.model('Student')指的是当前这个类&#125;;//创建修改的静态方法studentSchema.statics.xiugai = function(conditions,update,options,callback)&#123; this.model(\"Student\").update(conditions, update, options, callback);&#125;//创建了一个模型，就是学生模型，就是学生类。//类是基于schema创建的。var studentModel = db.model('Student', studentSchema); MongoVUE连接MongoDB不显示数据问题 mongoDB3.2版本之后默认开启的存储引擎是 wiredTiger，使用这种存储引擎存储的数据只能在命令行中看到，在 mongoVUE 中看不到。 所以，需要换成 mmapv1 操作引擎，此时就可以在 mongoVUE 中看到 Collections 下的内容1mongod --storageEngine mmapv1 --dbpath D:\\mongo(路径) 选择 mmapv1存储引擎后，ns 后缀文件就是数据库","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://dpfblog.com/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://dpfblog.com/tags/MongoDB/"},{"name":"mongoose","slug":"mongoose","permalink":"http://dpfblog.com/tags/mongoose/"}]},{"title":"在线竞拍网站","slug":"auction-angular","date":"2017-08-25T14:49:53.000Z","updated":"2017-10-16T04:09:02.000Z","comments":true,"path":"2017/08/25/auction-angular/","link":"","permalink":"http://dpfblog.com/2017/08/25/auction-angular/","excerpt":"","text":"简介👉 GitHub: https://github.com/pengfeidai/auction-Angular 这一个基于 Angular4.0 、Nodejs 和 Express 的小型电子产品售卖平台，使用了 Http 通讯，路由，服务，依赖注入，pipe管道，响应式表单等技术。 image image 技术栈【前端】 ES6：ECMAScript 新一代语法，这也是以后的趋势 Bootstrap：界面框架 Angular: 前端开发框架 Angular 路由器： 包含多种服务(RouterModule)、多种指令(RouterOutlet、RouterLink、RouterLinkActive)、 和一套配置(Routes)等。 http通讯：通过http通讯获取服务端数据 pipe 管道：负责处理原始值到显示值的转化 响应式表单：使用特定指令，将模板上的html元素与底层的数据模型连接在一起 【后端】 Nodejs: 使用Nodejs创建服务器 Express: 使用Express创建restful的http服务 【自动化构建】 Angular CLI: 全新命令行界面工具 实现细节首页 左侧为搜索表单，主要使用了 FormBuilder, FormControl,FormGroup，使用filter实现搜索效果。 右侧为一个轮播图组件，利用bootstrap框架实现。下面产品列表的数据来自后端模拟的数据，通过http通讯来获取，并将其展示在页面。 产品详情页 通过产品 id 来获取参数，将产品信息以及评论列表展示在页面，可实现关注、发表评论、评分功能。 收获 对 Angular 的组件、指令、依赖注入、http通讯、数据绑定等有了基本了解 了解了 Angular 组件之间的交互、传值 熟悉了在 Angular 项目中使用第三方插件（如jQuery,bootstrap） 熟悉了组件化、模块化的开发思维 再次熟悉项目开发流程：项目分析设计 -&gt; 项目环境搭建 -&gt; 依赖安装 -&gt; 页面架构设计 -&gt; 组件开发 -&gt; 测试联调 -&gt; 发布上线","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://dpfblog.com/tags/Angular/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://dpfblog.com/tags/Bootstrap/"}]},{"title":"Angular4.0http通讯，nodejs搭建服务器","slug":"Angular4-0http，nodejs","date":"2017-08-25T08:54:14.000Z","updated":"2017-09-02T09:00:28.000Z","comments":true,"path":"2017/08/25/Angular4-0http，nodejs/","link":"","permalink":"http://dpfblog.com/2017/08/25/Angular4-0http，nodejs/","excerpt":"","text":"前言最近在学习 Angular4.0，在学习过程中学到一些 http 服务端通讯以及跨域知识，将之记录下来。下面将附上实现步骤以及项目源码。 搭建一个服务器第一步：创建一个新的文件夹，取名为 server。 第二步： 右键打开 Git Bash Here，然后 npm init -y, ide自动生成一个package.json文件，如下： 123456789101112&#123; &quot;name&quot;: &quot;server&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 第三步： 生成node_modules文件夹和package-lock.json文件。 1npm i @types/node --save 作用：引入 node 的类型定义文件，可以在typesscript里用JavaScript的库 第四步： 创建一个新的tsconfig.json文件，用来告诉编译器如何将typesscript编译成javascript 12345678910111213&#123; \"compilerOptions\": &#123; \"target\": \"es5\", // 编译成 es5 规范的脚本 \"module\": \"commonjs\", // 用的 commonjs 模块规范 \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"outDir\": \"build\", // 编译完后 js 文件存放的目录是 build \"lib\": [\"es6\"] // &#125;, \"exclude\": [ \"node_modules\" ]&#125; 第五步： 安装 express 框架，简化配置操作 1npm install espress --save 第六步： 引入 espress 的类型定义文件，可以使用 typesscript 来开发 1npm install @types/espress --save 此时，package.json 文件下会多出安装的几个依赖，如下： 1234567891011121314151617&#123; &quot;name&quot;: &quot;server&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;@types/express&quot;: &quot;^4.0.37&quot;, &quot;@types/node&quot;: &quot;^8.0.25&quot;, &quot;express&quot;: &quot;^4.15.4&quot; &#125;&#125; 第七步： 配置好了，就开始写一个简单的程序，创建一个server文件夹，auction_server.ts 12345678910111213141516171819202122232425262728293031323334353637383940import * as express from 'express';const app = express();export class Product &#123; constructor( public id: number, public title: string, public price: number, public rating: number, public desc: string, public imgUrl: string, public categories: Array&lt;string&gt; ) &#123;&#125;&#125;const products: Product [] = [ new Product(1, '华为荣耀8', 1999, 3.5, '这是第一部手机，是我在学习Angular入门实战时创的', '../assets/images/1.jpg', ['电子产品', '手机']), new Product(2, 'vivo x9s', 2999, 2.5, '这是第二部手机，是我在学习Angular入门实战时创建的', '../assets/images/2.jpg', ['手机','硬件设备']), new Product(3, '魅蓝note6', 3999, 4.5, '这是第三部手机，是我在学习Angular入门实战时创建的', '../assets/images/3.jpg', ['电子产品']), new Product(4, 'Iphone 8', 1899, 3.5, '这是第四部手机，是我在学习Angular入门实战时创建的', '../assets/images/4.jpg', ['电子产品', '手机']), new Product(5, '红米4X', 5999, 3.5, '这是第五部手机，是我在学习Angular入门实战时创建的', '../assets/images/5.jpg', ['硬件设备']), new Product(6, '三星 S8', 3899, 2.5, '这是第六部手机，是我在学习Angular入门实战时创建的', '../assets/images/6.jpg', ['电子产品'])];app.get('/', (req, res) =&gt; &#123; res.send('Hello Express!');&#125;);app.get('/api/products', (req, res) =&gt; &#123; res.json(products);&#125;);app.get('/api/product/:id', (req, res) =&gt; &#123; res.json(products.find((product) =&gt; product.id == req.params.id));&#125;);const server = app.listen(8000, \"localhost\", () =&gt; &#123; console.log('服务器已启动！');&#125;); 编译会自动生成一个build文件夹下的 auction_server.js文件，只修改ts文件就可以了。 第八步： 启动服务器（普通） 1node build/auction_server.js 第九步： 安装 nodemon（简便） 1npm install -g nodemon 作用：监控代码，自动重启node服务器，更新浏览器页面，不用每次更改代码都启动 启动 1nodemon build/auction_server.js 效果图展示 image 创建Angular应用利用命令行工具 Angular CLI 创建一个名为 client 的 Angular 项目，并使用 ng g 命令自动生成模板文件。 如何生成 Angular 项目，请看另一篇文章：学会使用Angular CLI命令行工具 首先app.module.ts里要引入http模块 12345678910111213141516171819202122import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component';import &#123; ProductComponent &#125; from './product/product.component';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http';@NgModule(&#123; declarations: [ AppComponent, ProductComponent ], imports: [ BrowserModule, FormsModule, HttpModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 2.product.component.ts12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Http, Headers &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs';import 'rxjs/Rx';@Component(&#123; selector: 'app-product', templateUrl: './product.component.html', styleUrls: ['./product.component.css']&#125;)export class ProductComponent implements OnInit &#123; products: Observable&lt;any&gt;; constructor(private http: Http) &#123; let myHeaders: Headers = new Headers(); myHeaders.append('Authorization', 'Basic 123456'); this.products = this.http.get('/api/products', &#123;headers: myHeaders&#125;) .map((res) =&gt; res.json()); &#125; ngOnInit() &#123; &#125;&#125; 3.product.compoent.html 12345678&lt;div&gt; 商品信息&lt;/div&gt;&lt;ul&gt; &lt;li *ngFor=&quot;let product of products | async&quot;&gt; &#123;&#123;product.title&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 以上应用已经完成，这时候你启动服务器，商品信息并没有出来，商品请求报了 404 问题，这是什么原因呢？ image 这是因为服务的请求发往的是当前应用的相对路径，默认发送的请求是 http://localhost:4200，而服务运行在 8000 端口，为了让 http 发送的请求发往一个指定的路径，则需要以下配置。 Angular实现跨域请求1.在 client 目录下中，创建一个 proxy.conf.json 的文件，配置如下： 12345&#123; \"/api\": &#123; \"target\": \"http://localhost:8000\" &#125;&#125; 当应用发出去的请求是以 /api 开头时，把这些请求全部转发到 http://localhost:8000 这个地址。 2.在package.json文件的start里添一段代码--proxy-config proxy.conf.json，如下： 1&quot;start&quot;: &quot;ng serve --proxy-config proxy.conf.json&quot;, 3.启动1npm run start 注意：切勿使用 ng s。 这时候，商品信息都能显示出来，以上问题得到解决。 image 结束语本篇文章涉及到的 http 通讯和搭建 nodejs 服务器内容可能只是一些初级知识，但希望对新手有所帮助，各位大佬们不喜勿喷。 项目源码：https://github.com/pengfeidai/auction-Angular","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://dpfblog.com/tags/Angular/"},{"name":"http","slug":"http","permalink":"http://dpfblog.com/tags/http/"},{"name":"Node.js","slug":"Node-js","permalink":"http://dpfblog.com/tags/Node-js/"},{"name":"跨域","slug":"跨域","permalink":"http://dpfblog.com/tags/跨域/"}]},{"title":"学会使用Angular CLI命令行工具","slug":"Angular-CLI","date":"2017-08-20T08:26:24.000Z","updated":"2017-08-31T08:57:28.000Z","comments":true,"path":"2017/08/20/Angular-CLI/","link":"","permalink":"http://dpfblog.com/2017/08/20/Angular-CLI/","excerpt":"","text":"简介官方文档：https://angular.cn/guide/quickstart 步骤1. 设置开发环境如果你的机器上还没有 Node.js 和 npm，请先安装它们。 全局安装 Angular CLI1npm install -g @angular/cli 步骤2. 创建新项目打开终端窗口。 运行下列命令来生成一个新项目以及应用的骨架代码：1ng new my-app 步骤3. 启动开发服务器进入项目目录，并启动服务器。12345cd my-appng serve --open// 或者npm run start ng serve命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。 使用 --open（或-o）参数可以自动打开浏览器并访问 http://localhost:4200/。 步骤4. 编辑我们的第一个Angular组件这个CLI为我们创建了第一个 Angular 组件。 它就是名叫 app-root 的根组件。 你可以在./src/app/app.component.ts 目录下找到它。 打开这个组件文件，可以修改 title 属性，例如：123export class AppComponent &#123; title = &apos;My First Angular App&apos;;&#125; 浏览器会自动刷新，而我们会看到修改之后的标题。 打开 src/app/app.component.css 可以给这个组件设置一些样式，例如：12345h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125; 步骤5. 打包测试123ng build --prod //默认生成/dist目录，并将打包后的结果存放在此ng test //使用 karma 运行单元测试。 爬坑==打包编译后 html 空白问题解决：== 在package.json文件的scripts中修改命令： 1&quot;build&quot;:&quot;ng build --base-href ./&quot; //–base-href后面替换成打包后的base路径 执行 1npm run build 注意： 切勿使用 ng s启动。 常用命令ng new1ng new my-app --routing // 路由 ng g ==自动生成组件==，在 src/app 目录下生成4个 xx 模板文件，并更新 app.module.ts 文件1ng g component xx ==生成服务：==1ng g service productService ==自定义管道，生成管道：==1ng g pipe pipe/multiple","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://dpfblog.com/tags/Angular/"},{"name":"Angular CLI","slug":"Angular-CLI","permalink":"http://dpfblog.com/tags/Angular-CLI/"}]},{"title":"JavaScript最全设计模式详解","slug":"JavaScript设计模式","date":"2017-08-10T07:29:04.000Z","updated":"2017-08-21T02:54:02.000Z","comments":true,"path":"2017/08/10/JavaScript设计模式/","link":"","permalink":"http://dpfblog.com/2017/08/10/JavaScript设计模式/","excerpt":"","text":"简介让系统代码可重用、可扩展、可解耦、更容易被人理解且保证代码可靠性。设计模式使代码真正工程化。 image 设计原则： 开闭原则： 对扩展开放，对修改关闭 里氏转换原则： 子类继承父类，单独完全可以运行 依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型 接口隔离原则： 每一个接口应该是一种角色 合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分 迪米特原则： 一个对象应对其他对象有尽可能少的了解 单例模式概念保证一个类只有一个实例，实现方法是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，确保一个类只有一个实例对象。 在 JavaScript 中，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 123456789101112131415161718192021222324var Singleton = (function () &#123; var instantiated; function init() &#123; /*这里定义单例代码*/ return &#123; publicMethod: function () &#123; console.log('hello world'); &#125;, publicProperty: 'test' &#125;; &#125; return &#123; getInstance: function () &#123; if (!instantiated) &#123; //确保只有一个实例 instantiated = init(); //使用init方法，是使publicMethod和publicProperty只在要使用的时候才初始化; &#125; return instantiated; &#125; &#125;;&#125;)();/*调用公有的方法来获取实例:*/Singleton.getInstance().publicMethod(); // hello world 作用和注意事项模式作用： 模块间通信 系统中某个类的对象只能存在一个 保护自己的属性和方法 注意事项： 注意this的使用 闭包容易造成内存泄露，不需要的要赶快清除 注意new的成本。（继承） 实例在网页上实现一个登陆弹框，无论我们点击多少次登陆按钮，界面上始终只会显示一个登陆弹框，无法再创建第二个。 源码下载 &nbsp;&nbsp;&nbsp; demo演示 （1）获取DOM对象123var $ = function(id) &#123; return typeof id === 'string' ? document.getElementById(id) : id;&#125;; 为了便于之后关于DOM的一些操作，我们这里利用函数式编程的原理将获取目标 id 的元素对象方法封装了一下，直接利用 $(id) 就可以获取。 （2）弹框构造函数12345var Modal = function(id, html) &#123; this.html = html; this.id = id; this.open = false;&#125;; 这里我们声明了一个 Modal 作为弹框的构造函数，并且再其内部定义了公有属性 html、id 和 open。html 用来定义弹框内部的内容，id 用来给弹框定义 id 名称，open 用于判断弹框是否打开。 （3）open方法123456789101112131415Modal.prototype.create = function() &#123; if (!this.open) &#123; var modal = document.createElement('div'); modal.innerHTML = this.html; modal.id = this.id; document.body.appendChild(modal); setTimeout(function() &#123; modal.classList.add('show'); &#125;, 0); this.open = true; &#125;&#125;; 在 Modal 的原型链上定义了 create 方法，方法内部我们创建并向 DOM 中插入弹框，同时给弹框加上一个 class 为 “show” 的动画效果。 （4）close方法123456789101112Modal.prototype.delete = function() &#123; if (this.open) &#123; var modal = $(this.id); modal.classList.add('hide'); setTimeout(function() &#123; document.body.removeChild(modal); &#125;, 200); this.open = false; &#125;&#125;; 定义了 open 方法后我们这里定义关闭弹框的方法，在其内部给弹框对象添加 hide 类动画效果，最后在页面上移除弹框对象。 （5）创建实例123456var createIntance = (function() &#123; var instance; return function() &#123; return instance || (instance = new Modal('modal', '这是一个弹框')) &#125;&#125;)(); 这是实现单例模式的重要部分: 使用闭包封装了 instance 私有变量并返回一个函数 利用 || 语法判断如果 instance 不存在则执行后者的实例化 Modal 方法，存在则直接返回 instance，确保了只存在一个弹框实例 （6）按钮操作12345678910var operate = &#123; setModal: null, open: function() &#123; this.setModal = createIntance(); this.setModal.create(); &#125;, delete: function() &#123; this.setModal ? this.setModal.delete() : ''; &#125;&#125;; 这里我们将按钮操作放在 operate 对象里，使得打开和关闭操作可以通过this获取实例setModal。 （7）绑定事件1234567$('open').onclick = function() &#123; operate.open();&#125;;$('delete').onclick = function() &#123; operate.delete();&#125;; 最后我们将打开和删除方法绑定到两个按钮上去，至此我们用单例模式实现的弹框demo就实现了。 构造函数模式概念 构造函数用于创建特定类型的对象——不仅声明了使用过的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。 作用和注意事项模式作用： 用于创建特定类型的对象 第一次声明的时候给对象赋值 自己声明构造函数，赋予属性和方法 注意事项： 声明函数的时候处理业务逻辑 区分和单例的区别，配合单例实现初始化 构造函数大写字母开头 注意 new 的成本 （继承） 实例强制使用new123456789101112131415161718function Person(name, age, job) &#123; if (!(this instanceof Person)) &#123; return new Person(name, age, job); &#125; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; return this.name + 'is' + this.age + 'years old'; &#125;&#125;var person1 = new Person(\"Davis\", 22, \"student\");var person2 = Person(\"Faker\", 21, \"player\");console.log(person1.sayName()); // Davis is 22 years oldconsole.log(person2.sayName()); // Faker is 21 years old 建造者模式概念 建造者模式可以将一个复杂的对象的构建与其表示相分离，使同样的构建过程可以创建不同的表示。如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。建造者模式实际就是一个指挥者，一个建造者，一个使用指挥者调用具体建造者工作得出结果的客户。主要用于“分步骤构建一个复杂的对象”。 作用和注意事项模式作用： 分步创建一个复杂的对象 解耦封装过程和具体创建组件 无需关心组件如何组装 注意事项： 一定要一个稳定的算法进行支持（“分步骤”是一个稳定的算法） 加工工艺是暴露的 实例一个土豪需要建一个别墅，然后直接找包工头，包工头再找工人把别墅建好。这里土豪不用直接一个一个工人的去找。只需包工头知道土豪需求，然后去找工人，工人干活，土豪也不需要知道房子具体怎么建，最后能拿到房就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1.产出东西是房子//2.包工头调用工人进行开工而且他要很清楚工人们具体的某一个大项//3.工人是盖房子的 工人可以建厨房、卧室、建客厅//4.包工头只是一个接口而已 他不干活 他只对外说我能建房子function House() &#123; this.kitchen = \"\"; this.bedroom = \"\"; this.livingroom = \"\";&#125;function Contractor() &#123; this.construct = function(worker) &#123; worker.construct_kitchen(); worker.construct_bedroom(); worker.construct_livingroom(); &#125;&#125;function Worker() &#123; this.construct_kitchen =function() &#123; console.log(\"厨房建好了\"); &#125; this.construct_bedroom = function() &#123; console.log(\"卧室建好了\"); &#125; this.construct_livingroom = function() &#123; console.log(\"客厅建好了\"); &#125; this.submit = function() &#123; var _house = new House(); _house.kitchen = \"finished\"; _house.bedroom = \"finished\"; _house.livingroom = \"finished\"; return _house; &#125;&#125;;var worker = new Worker();var contractor = new Contractor();contractor.construct(worker);// 主人要房子var myhouse = worker.submit();console.log(myhouse); 工厂模式概念工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型（抽象工厂）。 作用和注意事项模式作用： 对象构建十分复杂 需要依赖具体的环境创建不同的实例 处理大量具有相同属性的小对象 注意事项： 1、不能滥用工厂，有时候仅仅是给代码增加复杂度 实例简单工厂模式12345678910111213141516var XMLHttpFactory = function() &#123;&#125;;XMLHttpFactory.createXMLHttp = function() &#123; var XMLHttp = null; // XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象 if (window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp;&#125;;var AjaxHander = function() &#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); /*...具体操作... */&#125; 抽象工厂模式12345678910111213141516171819202122232425262728var XMLHttpFactory = function() &#123;&#125;;XMLHttpFactory.prototype = &#123;// 如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类 createFactory:function() &#123; throw new Error(\"This is an abstract class\"); &#125;&#125;var XHRHandler = function() &#123; XMLHttpFactory.call(this);&#125;;XHRHandler.prototype = new XMLHttpFactory();XHRHandler.prototype.constructor = XHRHandler; // 重新定义 createFactory 方法XHRHandler.prototype.createFactory = function() &#123; var XMLHttp = null; if (window.XMLHttpRequest) &#123; XMLHttp = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp;&#125;var AjaxHander = function() &#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); /*...具体操作... */&#125; 抽象工厂只留一个接口，不做具体的事，让别的子类来继承我这个类，然后做它自己的事。 代理模式概念代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。代理模式使得代理对象控制具体对象的引用。代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。 作用和注意事项模式作用： 远程代理（一个对象将不同空间的对象进行局部代理） 虚拟代理（根据需要创建开销很大的对象，如图片预加载） 安全代理（控制真实对象的访问权限） 智能指引（调用对象代理处理另外一些事情，如垃圾回收机制） 注意事项： 不能滥用代理，有时候仅仅是给代码增加复杂度 实例12345678910111213141516171819202122// 代理模式需要三方// 1.买家function buyer() &#123; this.name = \"Davis\";&#125;// 2.中介function agent() &#123;&#125;agent.prototype.sell = function() &#123; new seller(new buyer()).sell(\"50万\")&#125;// 3.卖家 收钱function seller(buyer) &#123; this.buyer_name = buyer.name; this.sell = function(money) &#123; console.log(\"收到了来自\" + this.buyer_name + money + \"人民币\"); // 收到了来自Davis50万人民币 &#125;&#125;(new agent).sell(); 虚拟代理实现图片预加载12345678910111213141516171819202122232425262728293031// 图片加载函数var myImage = (function() &#123; var imgNode = document.createElement(\"img\"); document.body.appendChild(imgNode); return &#123; // 提供一个对外的setSrc接口，外界调用这个接口，可以给该img标签设置src属性 setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 引入代理对象var proxyImage = (function() &#123; var img = new Image; img.onload = function() &#123; // 图片加载完成，正式加载图片 myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; // 图片未被载入时，加载一张提示图片 myImage.setSrc(\"file://c:/loading.png\"); img.src = src; &#125; &#125;&#125;)();// 调用代理对象加载图片proxyImage.setSrc(\"http://images/water.jpg\"); 命令模式概念将请求封装成对象，分离命令接受者和发起者之间的耦合。命令执行之前在执行对象中传入接受者，主要目的相互之间的解耦。简单而言分为三个对象： 发起者：发出调用命令即可，具体如何执行，谁执行并不需要清楚。 接受者：有对应的接口处理不同的命令，至于命令是什么，谁发出的，不用关心。 命令对象：上面讲发起者和接受者分开了，二者之间需要个连接桥梁。这就是命令对象。命令对象接受发送者的调用，然后调用接受者的相应接口。 作用和注意事项模式作用： 将函数的封装、请求、调用结合为一体 调用具体的函数解耦命令对象与接收对象 提高程序模块化的灵活性 注意事项： 不需要借口一致，直接调用函数即可，以免造成浪费 实例场景如下：有个按钮button，点击之后，调用menu对象的refresh方法，输出“刷新”的内容。 12345678910111213141516171819202122232425262728// 发送者var setCommond = function(button, fn) &#123; button.onClick = function() &#123; fn() &#125;&#125;;// 执行命令者var menu = &#123; reFresh: function() &#123; console.log(\"刷新\"); &#125;, add: function() &#123; console.log(\"增加\"); &#125;, delete: function() &#123; console.log(\"删除\"); &#125;&#125;;// 命令对象var commondObj = function(reciver) &#123; return function() &#123; reciver.reFresh(); &#125;&#125;;var commondObj1 = commondObj(menu);setCommond(btn1, commondObj1); 发送者(setCommond)：不关心给哪个button，以及绑定什么事件，只要通过参数传入就好。 命令对象(commondObj):只需要接收到接受者的参数，当发送者发出命令时，执行就好。 接受者(menu):不用关心在哪里被调用被谁调用，只需要按需执行就好了。 策略模式概念定义一系列方法，封装起来使他们可以相互替换。也就是将策略封装在策略类中，当发起请求时管理类将请求委托给对应策略类。 发起者：发出调用命令即可，具体如何执行，谁执行并不需要清楚。 接受者：有对应的接口处理不同的命令，至于命令是什么，谁发出的，不用关心。 命令对象：上面讲发起者和接受者分开了，二者之间需要个连接桥梁。这就是命令对象。命令对象接受发送者的调用，然后调用接受者的相应接口。 作用模式作用： 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。 策略模式中的代码可以复用。 实例假设我们现在有这样一个需求：需要根据form表单元素的不同类型，当点击的时候输出对应的表单元素类型。 123456789101112131415161718192021222324252627 /** * 针对不同情况的策略算法封装在策略类fucs中， * 从调用事件中去除繁琐的if或者switch逻辑判断。达到解耦的目的 * 加入后面再增加‘select’的选项增加对应的方法即可 */ var funcs = &#123; text: function() &#123; console.log('this is text') &#125;, radio: function() &#123; console.log('this is radio') &#125;, checkbox: function() &#123; console.log('this is checkbox') &#125;, default: function() &#123; console.log('this is default') &#125; &#125; var renderDom = function(type) &#123; /** * 只需要根据不同的入参，自行匹配策略类中的接口即可。 */ return (funcs[type] || funcs['default'])() &#125;renderDom('checkbox') 策略对象就是funcs对象，里面的不同属性接口对应的方法就是策略。与逻辑判断分离开，如果有不同的情况的出现，对应的增加属性接口即可。 renderDom方法就是对应的管理类，只需要根据不同的type，去调用funcs不同的方法就ok了。如果type没有对应的接口，那就调用默认的default对应接口。 调用事件，就保持不变。将tyoe类型传过去就好了。 职责链模式概念职责链由多个不同的对象组成，发送者是发送请求的对象，而接收者则是链中那些接收请求并且对其进行处理或传递的对象。请求本身有时候也可以是一个对象，它封装了和操作有关的所有数据，基本实现流程如下： 发送者知道链中的第一个接收者，它向这个接收者发送该请求。 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。 如果没有任何接收者处理请求，那么请求会从链中离开。 实例现有A、B、C、D四个生产线，生产总量为2100，每个生产线的生产量未知且在0~2100(包括0和2100，保证总量为2100即可)，生产完毕后，分6次进行运输，规定每台车辆只能运350，且装满后才能够出发，装车顺序为ABCD,即上一个生产线生产的东西装完后才能够装下一个生产线的东西，要求根据每条生产线的生产量，给出每台车辆的托运安排。 例如： A：100 ， B：1400 ，C：500 ， D：100托运安排：第一辆车： A：100 ， B：250第二辆车： A：0 ， B：350第三辆车： A：0 ， B：350第四辆车： A：0 ， B：350第五辆车： A：0 ， B：100 ，C：250第六辆车： A：0 ， B：0 ， C：250 ，D：100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class WearHouse&#123; constructor(volume,wearHouse)&#123; this.volume=volume; this.wearHouse=wearHouse; this.outString=[]; &#125; next(take)&#123; if(this.wearHouse!=undefined) &#123; this.wearHouse.takeOut(take).forEach((subT) =&gt; &#123; this.outString.push(subT) &#125;) &#125; &#125; takeOut(num)&#123; if(num&gt;this.volume)&#123; num-=this.volume; var temp=this.volume; this.volume=0; this.outString.push(this.print(0,temp)); this.next(num); &#125;else&#123; this.volume-=num; this.outString.push(this.print(this.volume,num)); &#125; var temOut=this.outString; this.outString=[]; return temOut; &#125; print(volumn,takeNum)&#123;&#125; &#125; class WearHouseA extends WearHouse&#123; print(volumn,takeNum)&#123; return ['A',takeNum]; &#125; &#125; class WearHouseB extends WearHouse&#123; print(volumn,takeNum)&#123; return ['B',takeNum]; &#125; &#125; class WearHouseC extends WearHouse&#123; print(volumn,takeNum)&#123; return ['C',takeNum]; &#125; &#125; class WearHouseD extends WearHouse&#123; print(volumn,takeNum)&#123; return ['D',takeNum]; &#125; &#125; var D=new WearHouseD(100,undefined); var C=new WearHouseC(500,D); var B=new WearHouseB(1400,C); var A=new WearHouseA(100,B); var strSet=[]; for(var a=0;a&lt;6;a++)&#123; strSet.push(...A.takeOut(350)); &#125; console.log(strSet); 结束语使用设计模式的是为了提高我们解决问题的效率，不同的设计模式也是针对不同环境的特定方案，不仅仅是单独的某一种设计模式，大多数情况下都是多个模式共存的。切勿为了使用设计模式而强行引入，增加代码复杂度。 学习资源：链接：http://pan.baidu.com/s/1i5BYiGH 密码：3s4v","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://dpfblog.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://dpfblog.com/tags/设计模式/"}]},{"title":"cubic-bezier(贝塞尔曲线)","slug":"cubic-bezier","date":"2017-08-05T08:58:46.000Z","updated":"2017-08-18T14:07:20.000Z","comments":true,"path":"2017/08/05/cubic-bezier/","link":"","permalink":"http://dpfblog.com/2017/08/05/cubic-bezier/","excerpt":"","text":"简介cubic-bezier 又称三次贝塞尔，主要是为 animation 生成速度曲线的函数, CSS3 动画速度的控制通过三次贝塞尔曲线函数实现，定义规则为： cubic-bezier (x1, y1, x2, y2)。 cubic-bezier：http://cubic-bezier.com/ css3中常用的几个动画效果： 12345ease: cubic-bezier(0.25, 0.1, 0.25, 1.0) // 开始和结束慢，中间快linear: cubic-bezier(0.0, 0.0, 1.0, 1.0) // 匀速ease-in: cubic-bezier(0.42, 0, 1.0, 1.0) // 开始慢ease-out: cubic-bezier(0, 0, 0.58, 1.0) // 结速慢ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0) // 与ease类似，但比ease幅度大 基本原理贝塞尔曲线通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形，绘制出一条光滑曲线并以曲线的状态来反映动画过程中速度的变化。 image 从上图我们知道的是 cubic-bezier 的取值范围: A：默认值 (0, 0) B：动态取值 (x1, y1) C：动态取值 (x2, y2) D：默认值 (1, 1) 其中 X 轴的取值范围是 [0, 1]，当取值超出范围时 cubic-bezier 将失效；Y 轴的取值没有规定，当然也毋须超过 [0, 1] 过大。 我们需要关注的是 B 和 C 两点的取值，这两点就是所要动态操控的两个点了,对应cubic-bezier (x1,y1,x2,y2)中的四个参数。 实例演示下面用一个简单的实例来看看效果：demo演示 html 部分12&lt;div class=\"normal\"&gt;&lt;/div&gt;&lt;div class=\"custom\"&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233.normal &#123; margin-bottom: 10px; width: 50px; height: 50px; background-color: #ff0000; border-radius: 50%; -webkit-transition: all 2s; -moz-transition: all 2s; -o-transition: all 2s; transition: all 2s;&#125;.normal:hover &#123; -webkit-transform: translateX(150px); -moz-transform: translateX(150px); -o-transform: translateX(150px); transform: translateX(150px);&#125;.custom &#123; width: 50px; height: 50px; border-radius: 50%; background-color: blue; -webkit-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); -moz-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); -o-transition: all 2s cubic-bezier(.94,-0.25,.32,1.31); transition: all 2s cubic-bezier(.94,-0.25,.32,1.31);&#125;.custom:hover &#123; -webkit-transform: translateX(300px); -moz-transform: translateX(300px); -o-transform: translateX(300px); transform: translateX(300px);&#125; 红色小球采用默认的速度曲线是 ease，蓝色小球采用自定义cubic-bezier(.94,-0.25,.32,1.31),呈现蓄力加速效果。 transition（过渡）transition属性 transition-property: 过渡属性(默认值为all) transition-duration: 过渡持续时间(默认值为0s) transiton-timing-function: 过渡函数(默认值为ease函数) transition-delay: 过渡延迟时间(默认值为0s) 语法1transition: property duration timing-function delay; animation（动画）animation属性结合@ keyframes使用，animation中的animation-name需要设置成@ keyframes的name一致。例如： 12345678910111213141516171819202122232425262728293031&lt;style&gt;.box &#123; height: 100px; width: 100px; border: 15px solid black; animation: changebox 10s ease-in-out 3 alternate paused;&#125;.box:hover &#123; animation-play-state: running;&#125;@keyframes changebox &#123; 10% &#123; background: red; &#125; 50% &#123; width: 80px; &#125; 70% &#123; border: 15px solid yellow; &#125; 100% &#123; width: 180px; height: 180px; &#125;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; animation属性 animation-name: 指定要绑定到选择器的关键帧的名称 animation-duration: 动画指定需要多少秒或毫秒完成 animation-timing-function: 设置动画将如何完成一个周期 animation-delay: 设置动画在启动前的延迟间隔 animation-iteration-count: 定义动画的播放次数 animation-direction: 指定是否应该轮流反向播放动画 animation-fill-mode:规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式 animation-play-state: 指定动画是否正在运行或已暂停。语法 1animation: name duration timing-function delay iteration-count direction fill-mode play-state; transform（变形）transform 分为2D 和 3D，其主要包含以下几种变换：translate位移，scale缩放，rotate旋转，skew扭曲等。 2D变形： translate位移123transform: translate(50px, 100px);transform: translateX(50px); // x方向移动50pxtransform: translateY(100px); scale缩放123transform: scale(2, .5);transform: scaleX(2); // x方向增加一倍transform: scaleY(.5); // y方向缩小一倍 rotate旋转：rotate（正数表示顺时针旋转，负数表示逆时针旋转）1transform: rotate(30deg); skew扭曲123transform: skew(30deg, 30deg);transform: skewX(30deg);transform: skewY(30deg); 3D变形： translate位移： translate(x, y, z); scale缩放： scale(x, y, z); rotate旋转：rotate3d(x, y, z, angle) (angle:表示3D舞台上旋转的角度)","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://dpfblog.com/tags/CSS3/"}]},{"title":"深入理解Javascript面向对象","slug":"JS面向对象编程","date":"2017-07-28T06:52:56.000Z","updated":"2017-08-21T02:54:00.000Z","comments":true,"path":"2017/07/28/JS面向对象编程/","link":"","permalink":"http://dpfblog.com/2017/07/28/JS面向对象编程/","excerpt":"","text":"简介JavaScript 是一门基于对象的编程语言，在 JavaScript 中一切都是对象，包括函数，也是被当成第一等的对象对待，这正是 JavaScript 极其富有表现力的原因。 理解对象ECMA-262 关于对象的定义是：“无序属性的集合，其属性可以包含基本值、对象或者函数。” 严格说，对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 早期，创建对象就是创建一个 Object的实例，并为它添加属性( name、age )和方法( sayName() )，可以这么写： 123456var person = new Object();person.name = \"Davis\";person.age = 22;person.sayName = function () &#123; alert(this.name);&#125; 现在，对象字面量成为创建对象的首选模式，可以这么写： 12345678var person = &#123; name = \"Davis\", age: 22, sayName: function () &#123; alert(this.name); &#125;&#125;; 这两个例子中 person 对象事一样的，有相同的属性和方法。这些属性在创建时都有一些特征值(characteristic),JavaScript 通过这些特征值来定义他们的行为。 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 数据属性数据属性包含一个数据值的位置，在这个位置可以读取和写入值，具有如下4个特性： [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为 true。[[Enumerable]]: 表示能否通过for-in循环返回属性。直接在对象上定义的属性，默认为true。[[Writable]]: 表示能否修改属性的值。直接在对象上定义的属性，默认为true。[[Value]]: 包含这个属性的数据值；读取属性值的时候，从这个位置读取；写入属性值的时候，把值保存在这里。这个特性默认为undefined 要修改数据属性默认的特性，必须使用ECMAScript5中的Object.defineProperty()方法；接受三个参数：属性所在的对象、属性的名字、描述符对象；其中，数据属性描述符对象的属性必须是：configurable、enumerable、writable和value。12345678var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Davis&quot;&#125;);alert(person.name); //&quot;Davis&quot;person.name = &quot;XX&quot;;alert(person.name); //&quot;Davis&quot; 访问器属性访问器属性包含一对 getter 和 setter 函数。在读取访问器属性时，会调用 getter 函数，负责返回有效的值；在写入时，会调用 setter 函数并传入新值,负责决定如何处理数据。具有如下4个特性： [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为 true。[[Enumerable]]: 表示能否通过for-in循环返回属性。直接在对象上定义的属性，默认为true。[[Get]]: 在读取属性时调用的函数；默认值为undefined。在读取访问器属性时，会调用gette方法，这个函数负责返回有效的值。[[Set]]: 在写入属性时调用的函数；默认值为undefined。在写入访问器属性时，会调用setter方法并传入新值，这个函数负责决定如何处理数据。 访问器属性不能直接定义，必须使用Object.defineProperty()方法来定义。123456789101112131415161718var book = &#123; _year: 2016, edition: 5&#125;;Object.defineProperty(book, \"year\", &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125;&#125;);book.year = 2017;alert(book.edition); // 6 定义多个属性Object.defineProperties()方法，通过描述符一次性定义多个属性； 接收两个对象参数：第一个对象是要添加或修改其属性的对象；第二个对象的属性与第一个对象中要添加或修改的属性一一对应。1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2016 &#125;, edition: &#123; writable: true, value: 5 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125; &#125;&#125;); 以上代码在 book 对象上定义了两个数据属性( _year 和 edition )和一个访问器属性( year )。 读取属性的特性Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符； 接收两个参数：属性所在的对象，要读取其描述符的属性名称。 返回值是一个对象；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value；如果是访问器属性，这个对象的属性有configurable、enumerable、get、set。12345678910111213141516171819202122232425262728293031var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 5 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newVal) &#123; if (newVal &gt; 2016) &#123; this._year = newVal; this.edition += newVal - 2016; &#125; &#125; &#125;&#125;);var d = Object.getOwnPropertyDescriptor(book, \"_year\");alert(d.value); // 2016alert(d.configurable); // falsealert(type d.get); // \"undefined\"var d = Object.getOwnPropertyDescriptor(book, \"year\");alert(d.value); // undefinedalert(d.enumerable); // falsealert(type d.get); // \"function\" 对于数据属性_year, value 等于最初的值，configurable 是false，而 get 等于 undefined。 对于访问属性 year，value 等于 undefined，enumerable 是 false，而 get 是指向 getter函数的指针。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://dpfblog.com/tags/Javascript/"},{"name":"oop","slug":"oop","permalink":"http://dpfblog.com/tags/oop/"}]},{"title":"Vue实现轮播图组件","slug":"Vue-Carousel","date":"2017-07-22T13:37:50.000Z","updated":"2017-09-19T06:20:48.000Z","comments":true,"path":"2017/07/22/Vue-Carousel/","link":"","permalink":"http://dpfblog.com/2017/07/22/Vue-Carousel/","excerpt":"","text":"简介最近在学习 Vue，看到大多数项目首页都有轮播效果，然后自己也是做了一个轮播图，希望分享给大家。 主要技术 v-if: 条件渲染 v-for：列表渲染 v-bind：属性绑定 transition: 过渡效果 组件交互: 父组件通过 props 将数据传递给子组件 主要思路轮播图中，它显示的那张图片在浏览器中可以看到有dom元素。隐藏的是没有dom元素的。所以如果显示一张图片，实际上，轮播列表中只有一个元素是存在的，其他的都被删掉了。按照这个思路，就很简单了。想要轮播，设置：enter：右边→enter-to：正常位置，并且过渡完成→leave：正常位置→leave-to：左边，并且过渡完成。 在线预览👉http://www.dpfblog.com/Carousel/ 源代码项目源码：👉https://github.com/pengfeidai/Carousel","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://dpfblog.com/tags/Vue/"},{"name":"Carousel","slug":"Carousel","permalink":"http://dpfblog.com/tags/Carousel/"}]},{"title":"ES6编码风格","slug":"ES6编码风格","date":"2017-07-20T14:18:06.000Z","updated":"2017-09-26T02:35:16.000Z","comments":true,"path":"2017/07/20/ES6编码风格/","link":"","permalink":"http://dpfblog.com/2017/07/20/ES6编码风格/","excerpt":"","text":"块级作用域let 取代 varES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。123456&apos;use strict&apos;;if(true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。所以，建议不再使用var命令，而是使用let命令取代。 全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。1$ npm i -g eslint 然后，安装Airbnb语法规则。1$ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用ESLint检查这个文件。1234567$ eslint index.jsindex.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 解决浏览器兼容ES6特性使用 babel 转换工具： https://babeljs.io/","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://dpfblog.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://dpfblog.com/tags/ES6/"}]},{"title":"ES6，你真的知道吗","slug":"浅谈ES6核心内容","date":"2017-07-16T14:33:25.000Z","updated":"2017-08-21T02:53:16.000Z","comments":true,"path":"2017/07/16/浅谈ES6核心内容/","link":"","permalink":"http://dpfblog.com/2017/07/16/浅谈ES6核心内容/","excerpt":"","text":"ES6简介ECMAScript6（简称ES6）是 JavaScript 语言的下一代标准。在2015年6月正式发布，所以又称ES2015。由于目前并不是所有浏览器都能兼容 ES6 全部特性，但是 ES6 在实际项目中的广泛使用已成为一种趋势。所以作为一个前端开发者，ES6 的语法是我们必须掌握的。 在讲解 ES6 语法之前，我们得先了解下Babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。可在Babel官网 (http://babeljs.io/) 查看： image 使用Gulp 和 Babel 将 ES6 代码转换成 ES5 代码具体过程如下： 安装依赖 安装全局 Gulp 1npm install -g gulp 安装项目中使用的 Gulp 1npm install --save-dev gulp 安装 Gulp 上 Babel 的插件 1npm install --save-dev gulp-babel 安装 Babel 上将 ES6 转换成 ES5 的插件 1npm install --save-dev babel-preset-es2015 Gulp 配置 gulpfile.js 的内容 12345678var gulp = require(\"gulp\");var babel = require(\"gulp-babel\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/**/*.js\") // ES6 源码存放的路径 .pipe(babel()) .pipe(gulp.dest(\"dist\")); //转换成 ES5 存放的路径&#125;); 如果要生成 Soucemap， 则用 gulp-sourcemaps 12345678910111213var gulp = require(\"gulp\");var sourcemaps = require(\"gulp-sourcemaps\");var babel = require(\"gulp-babel\");var concat = require(\"gulp-concat\");gulp.task(\"default\", function () &#123; return gulp.src(\"src/**/*.js\") .pipe(sourcemaps.init()) .pipe(babel()) .pipe(concat(\"all.js\")) .pipe(sourcemaps.write(\".\")) .pipe(gulp.dest(\"dist\"));&#125;); Babel 配置在项目根路径创建文件 .babelrc。内容为：123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; 执行转换命令行中执行1gulp ES6常用特性let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments 这些是ES6最常用的几个语法，基本上学会它们，就可以满足我们日常的使用！下面就用用最通俗易懂的语言和例子来讲解它们。 let 与 const这两个的用途与var类似，都是用来声明变量的，但在实际运用中都有各自的特殊用途。 ES5只有全局作用域、函数作用域和eval作用域，没有块级作用域，这带来很多不合理的场景。 第一种，变量提升：就是var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部；不在函数内即在全局作用域的最顶部。这样就会引起一些误解。1234567console.log(a); // undefinedvar a = 3;// 等价于var a;console.log(a);a = 3; 而 let 就不会被变量提升12console.log(a); // a is not definedlet a = 3; 第二种场景就是内层变量覆盖外层变量。例如：123456789var name = 'Faker'while (true) &#123; var name = 'Davis' console.log(name) //Davis break&#125;console.log(name) //Davis 而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。123456789let name = 'Faker'while (true) &#123; let name = 'Davis' console.log(name) //Davis break&#125;console.log(name) //Faker 第三种场景就是用来计数的循环变量泄露为全局变量，例如：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用 let 则不会出现这个问题。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。123const PI = 3.1415926;PI = 8;console.log(PI); // invalid assignment to const `PI' 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require('moment') Set 和 Map 数据结构与 Array 增、删、改、查对比12345678910111213141516171819202122232425262728293031let map = new Map();let set = new Set();let array = [];// 增map.set('t', 1);set.add( &#123; t : 1 &#125; );array.push( &#123; t:1 &#125; );console.info( map, set, array ); // Map &#123; 't' =&gt; 1 &#125; Set &#123; &#123; t: 1 &#125; &#125; [ &#123; t: 1 &#125; ]// 查let map_exist = map.has( 't' );let set_exist = set.has( &#123;t:1&#125; );let array_exist = array.find(item =&gt; item.t)console.info(map_exist, set_exist, array_exist); //true false &#123; t: 1 &#125;// 改map.set('t', 2);set.forEach(item =&gt; item.t ? item.t = 2:'');array.forEach(item =&gt; item.t ? item.t = 2:'');console.info(map, set, array); // Map &#123; 't' =&gt; 2 &#125; Set &#123; &#123; t: 2 &#125; &#125; [ &#123; t: 2 &#125; ]// 删map.delete('t');set.forEach(item =&gt; item.t ? set.delete(item):'');let index = array.findIndex(item =&gt; item.t);array.splice(index,1);console.info(map, set, array); // Map &#123;&#125; Set &#123;&#125; [] class、extends、superES5中原型、构造函数，继承问题一直困扰我们。ES6引入了Class（类）的概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。123456789101112131415161718192021222324class Human &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(this.name + \" is sleeping\"); &#125;&#125;let man = new Human(\"Davis\");man.sleep(); //Davis is sleepingclass Boy extends Human &#123; constructor(name, age) &#123; super() this.name = name; this.age = age; &#125; info()&#123; console.log(this.name + 'is ' + this.age + 'years old'); &#125;&#125;let son = new Boy('Faker','8');son.sleep(); // Faker is sleepingson.info(); // Faker is 8 years old 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Boy类，该类通过extends关键字，继承了Human类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function 箭头函数ES6中新增的箭头操作符 =&gt; 简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，可以说是 ES6 最最常用的一个新特性了，看下面的实例：1234567891011// ES5let arr = [1, 3, 5, 7, 9];arr.forEach (function(val, key) &#123; return console.log(val, key);&#125;);// ES6let arr = [1, 3, 5, 7, 9];arr.forEach ((val, key) =&gt; console.log(val, key)); JavaScript语言的this对象指向是一个头疼的问题，在对象方法中使用this，必须非常小心。123456789101112class Human &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; setTimeout(function()&#123; console.log(this.name + \" is sleeping\"); &#125;, 1000) &#125;&#125;let man = new Human(\"Davis\");man.sleep(); // is sleeping 上面代码之所以不能输出 Davis，这是因为setTimeout中的this指向的是全局对象。为了让它能够正确的运行，传统的解决方法有两种：123456789101112// 第一种，将this传给self,再用self来指代thissleep() &#123; var self = this; setTimeout(function()&#123; console.log(self.name + \" is sleeping\"); &#125;, 1000)// 第二种，是用bind(this)sleep() &#123; setTimeout(function()&#123; console.log(self.name + \" is sleeping\") &#125;.bind(this), 1000) 使用箭头函数，非常方便：123456789101112class Human &#123; constructor(name)&#123; this.name = name; &#125; sleep() &#123; setTimeout( () =&gt; &#123; console.log(this.name + \"is sleeping\"); &#125;, 1000) &#125;&#125;let man = new Human(\"Davis\");man.sleep(); // Davis is sleeping 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string 模板字符串ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。12let num = Math.random();console.log(` num is $&#123;num&#125;`); // num is xx 不再通过 \\ 来做多行字符串拼接，模板字符串可以多行书写：1234$(\"#main\").html(` &lt;h1&gt;今天天气很好！&lt;/h1&gt; &lt;p&gt;产生一个随机数$&#123;num&#125;&lt;/p&gt;`); 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 destructuring 解构ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 用途一，交换变量的值，不再需要中间变量1234let a = 1;let b = 2;[a, b] = [b, a];console.log(a, b); // 2 1 用途二，提取JSON数据123456789let jsonData = &#123; id: 1, title: \"OK\", data: [5, 6]&#125;;let &#123;id, title, data:number&#125; = jsonData;console.log(id, title, number); // 1, \"OK\", [5, 6] 用途三，函数参数的定义1234567891011 // 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123;...&#125;f(&#123;z: 3, y: 2, x: 1&#125;); default默认参数default很简单，就是默认值。现在可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。1234567891011121314// 传统指定默认参数function say1(name) &#123; var name = name || 'Faker'; console.log( 'Hello ' + name );&#125;// ES6默认参数function say2(name='Davis') &#123; console.log(`Hello $&#123;name&#125;`);&#125;say1(); // Hello Fakersay1('Tom'); // Hello tomsay2(); //Hello Davissay2('Bob'); // Hello Bob 注意： say2(name=’tom’)这里的等号，指的是没有传这个参数，则设置默认值Davis，而不是给参数赋值。 rest参数rest参数只包括那些没有给出名称的参数； rest参数是Array的实例，可以直接应用sort, map, forEach, pop等方法； rest参数之后不能再有其它参数（即，只能是最后一个参数）； 函数的length属性，不包括rest参数；12345function fn(x, y, ...rest)&#123; console.log(rest)&#125;fn(1, \"cat\", \"dog\", 2); //[\"dog\", 2]console.log(fn.length); //2 Proxy 代理Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。1234567891011121314//定义被监听的目标对象let man = &#123; name: 'Davis', age: 21 &#125;;//定义处理程序let handle = &#123; set(receiver, property, value) &#123; console.log(property, 'is changed to', value); receiver[property] = value; &#125;&#125;;//创建代理以进行侦听man = new Proxy(man, handle);//做一些改动来触发代理man.age = 22; //age is change to 22man.name = \"Faker\"; // name is change to Faker PromisePromise对象状态 Promise/A+规范, 规定Promise对象是一个有限状态机。它三个状态： pending（执行中） Resolved（已完成） Rejected（已失败） 其中pending为初始状态，Resolved和rejected为结束状态（表示promise的生命周期已结束）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let val = 1;// 我们假设step1, step2, step3都是ajax调用后端或者是在Node.js上查询数据库的异步操作// 每个步骤都有对应的失败和成功处理回调// step1、step2、step3必须按顺序执行function step1(resolve, reject) &#123; console.log('步骤一：执行'); if (val &gt;= 1) &#123; resolve('Hello I am No.1'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;function step2(resolve, reject) &#123; console.log('步骤二：执行'); if (val === 1) &#123; resolve('Hello I am No.2'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;function step3(resolve, reject) &#123; console.log('步骤三：执行'); if (val === 1) &#123; resolve('Hello I am No.3'); &#125; else if (val === 0) &#123; reject(val); &#125;&#125;new Promise(step1).then(function(val)&#123; console.info(val); return new Promise(step2);&#125;).then(function(val)&#123; console.info(val); return new Promise(step3);&#125;).then(function(val)&#123; console.info(val); return val;&#125;).then(function(val)&#123; console.info(val); return val;&#125;);// 执行之后将会打印步骤一：执行Hello I am No.1步骤二：执行Hello I am No.2步骤三：执行Hello I am No.3Hello I am No.3 常用关键点： 在Promise定义时，函数已经执行了；Promise构造函数只接受一个参数，即带有异步逻辑的函数。这个函数在 new Promise 时已经执行了。只不过在没有调用 then 之前不会 resolve 或 reject。 在then方法中通常传递两个参数，一个 resolve 函数，一个 reject 函数。reject就是出错的时候运行的函数。resolve 函数必须返回一个值才能把链式调用进行下去。 resolve 返回一个新 Promise返回一个新Promise之后再调用的then就是新Promise中的逻辑了。 resolve 返回一个值返回一个值会传递到下一个then的resolve方法参数中。 GeneratorGenerator函数跟普通函数的写法有非常大的区别： function关键字与函数名之间有一个 *； 函数体内部使用yield语句，定义不同的内部状态； 123456789101112function* f() &#123; yield 'a'; yield 'b'; yield 'c'; return 'ending';&#125;let fn = f();console.log(fn.next()); // &#123; value: 'a', done: false &#125;console.log(fn.next()); // &#123; value: 'b', done: false &#125;console.log(fn.next()); // &#123; value: 'c', done: false &#125;console.log(fn.next()); // &#123; value: 'ending', done: true &#125; 第一次输出fn.next()返回一个简单的对象{value: “a”, done: false}，’a’就是f函数执行到第一个yield语句之后得到的值，false表示f函数还没有执行完，只是在这暂停。 第二次，返回的就是{value: “b”, done: false}，说明f函数运行到了第二个yield语句，返回的是该yield语句的返回值’b’。返回之后依然是暂停。 第三次，第四次同理，这样整个f函数就运行完毕了。 异步操作的同步化写法Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 例子：假设我在测试服务器的某目录建了4个文件，分别是’test.html’、’a.html’、’b.html’、’c.html’，后三个文件的文件内容跟文件名相同，现在我编辑’test.html’的代码，想要先ajax-get相对网址’a.html’，然后再回调里ajax-get相对网址’b.html’，然后在回调里ajax-get相对网址’c.html’。 12345678910111213141516171819function req(url) &#123; $.get(url, function(res)&#123; it.next(res); &#125;);&#125;// 生成器函数function* ajaxs() &#123; console.log(yield req('a.html')); console.log(yield req('b.html')); console.log(yield req('c.html'));&#125;var it = ajaxs(); // 遍历器对象it.next();// a.html// b.html// c.html 强调：只有当yield后面跟的函数先执行完，无论执行体里面有多少异步回调，都要等所有回调先执行完，才会执行等号赋值，以及再后面的操作。这也是yield最大的特性。 export、importexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口； import用于在一个模块中加载另一个含有export接口的模块。 导出一组对象 导出模块文件app.js：123456789101112131415class Human&#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(this.name + &quot; is sleeping&quot;); &#125;&#125;function walk() &#123; console.log(&apos;i am walking&apos;);&#125;function play() &#123; console.log(&apos;i am playing&apos;);&#125;export &#123; Human, walk &#125; 模块导出了两个对象：Human类和walk函数，能被其他文件使用。而play函数没有导出，为此模块私有，不能被其他文件使用。 main.js导入app.js模块1import &#123; Human, walk &#125; from &apos;app.js&apos;; Default导出使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。12... //类，函数等export default App; main.js导入app.js模块1import App from &apos;app.js&apos;; 结语以上这些是ES6最常用的几个语法，基本上学会它们，就可以满足我们日常的使用！ES6的新语法特性让前端和后端的差异越来越小了，我们必须要了解这些新的前沿知识（虽然ES8已经到来，但我相信目前还是ES6的时代），才能更好运用于项目中。 项目源码：https://github.com/pengfeidai/lottery-es6","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://dpfblog.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://dpfblog.com/tags/ES6/"},{"name":"gulp","slug":"gulp","permalink":"http://dpfblog.com/tags/gulp/"}]},{"title":"响应式网页开发你不知道的那些事","slug":"响应式网页开发应注意的那些事儿","date":"2017-07-11T14:52:28.000Z","updated":"2017-09-02T14:14:04.000Z","comments":true,"path":"2017/07/11/响应式网页开发应注意的那些事儿/","link":"","permalink":"http://dpfblog.com/2017/07/11/响应式网页开发应注意的那些事儿/","excerpt":"","text":"简介响应式网页设计通过使用弹性网格和布局、响应式图片、CSS media query等技术手段，使页面能够自动切换分辨率、图片尺寸及相关脚本功能，以适应不同设备，来满足用户在各种设备环境下的需求。响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。 image 媒体查询什么是媒体查询媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 如何在CSS文件中引入媒体查询媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式。 怎样使用media第一步：需要在html文档中添加以下代码，用来兼容移动设备的显示效果1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; width=device-width:宽度等于当前设备的宽度 initial-scale=1：初始的缩放比例（默认为1） minimum-scale=1：允许用户缩放到得最小比例（默认为1） maximum-scale=1：允许用户缩放到得最大比例（默认为1） user-scalable=no：用户不能手动缩放 第二步：怎样在CSS文件中写CSS响应式媒体查询1234567891011121314151617181920body &#123; font-size: 1.6rem; background: #f7f7f7;&#125;@media only screen and (max-width: 50em) &#123; body &#123; font-size: 1.2rem; background: #fff; &#125;&#125;@media only screen and (min-width: 30.0625em) and (max-width:50em)&#123;&#125;@media only screen and (max-width: 30em) &#123; body &#123; font-size: 1.0rem; background: #999; &#125;&#125; 在不同宽度下，改变背景颜色和字体大小 兼容性解决部分IE浏览器(IE9以下)，不支持 html5 和媒体查询。需要在 html 文档 &lt;head&gt;&lt;/head&gt;标签中添加以下代码。1234&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; html5shiv：解决IE浏览器(IE6、IE7、IE8)不支持HTML5的问题respond：使IE浏览器(IE6、IE7、IE8)支持媒体查询中的min-width和max-width 相对长度单位px: 像素，1个px相当于一个像素 em: 元素字体高度，相对参照物为父元素的 font-size。em 的值并不固定，会继承父元素的字体大小 rem: 元素字体高度，相对参照物为根元素 html,相于参照固定不变。目前，除 IE9 以下版本，所有浏览器均已支持rem 注意： 若rem没有在根元素（html字体）指定参照值，那浏览器默认1 rem就是16px,若rem有指定值，则1rem就是等于指定值 。 html设置为62.5%或者10px时会失效，是因为小于12px或者75%的字体大小不支持换算。这可能与有些浏览器不支持12px以下的大小有关。所以，使用rem单位，html的字体默认字体大小必须设置为12px或以上。若小于12px则浏览器换算时自动默认字体为12px。123456html &#123; font-size: 62.5%; /* 10÷16=62.5% */&#125;body &#123; font-size:1.2rem ; /* 12÷10=1.2 */&#125; 在响应式网页开发中，我们会更多的使用到 rem，而对 px的适应基本很少。 响应式广告现在大部分的网页都会有一个滚动广告(轮播图)，一个好的广告滚动组件支持： 支持不同的图片数量 支持响应式 具有良好的兼容性 现在网上滚动广告组件非常多，在这里我只推荐两种 Owl Carousel 2和 myfocus，非常轻量，使用文档非常齐全。这里，主要讲一下 Owl Carousel 2的用法。 Owl Carousel 2 下载之后的目录结构： 1234567891011121314Owlcarousel2/├── assets/│ ├── owl.carousel.css│ ├── owl.carousel.min.css // 主样式文件│ ├── owl.theme.default.css│ ├── owl.theme.default.min.css // 皮肤样式文件│ ├── owl.theme.green.css│ ├── owl.theme.green.min.css│ └── owl.video.play.png│├── owl.carousel.js├── owl.carousel.min.js├── LICENSE-MIT└── README.md html结构：12345678910111213&lt;div class=&quot;ad&quot;&gt; &lt;div class=&quot;owl-carousel owl-theme&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad001.png&quot; alt=&quot;&quot;&gt; // 图片尺寸480*480 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad002.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/ad003.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在html文件中引入css:12&lt;link rel=&quot;stylesheet&quot; href=&quot;OwlCarousel2/assets/owl.carousel.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;OwlCarousel2/assets/owl.theme.default.min.css&quot;&gt; 在html文件中引入js:123&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;OwlCarousel2/owl.carousel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt; main文件自己定义：123456789$(document).ready(function()&#123; $(&quot;.owl-carousel&quot;).owlCarousel(&#123; items: 1, // 一屏看到的图片数量 loop: true, // 循环滚动 autoplay: true, // 自动播放 autoplayTimeout: 3000, // 时间间隔 autoplayHoverPause: true //鼠标放在图片上暂停滚动 &#125;);&#125;); 当然现在滚动效果就已经完成了。不过还有一个问题，当屏幕尺寸放大或缩小时，始终都是480尺寸的图片，看起来就是不爽，那么如何能实现让图片在不同设备下自动切换成我们想要的尺寸呢？那么下面就需要用到响应式图片~ 响应式图片js和服务端控制提前在图片库准备三张480、800、1600尺寸的图片。1234567891011121314$(function()&#123; function makeImageResponsive()&#123; var img = $(&apos;.cotent img&apos;); var width = $(window).width(); if(width &lt;= 480)&#123; img.attr(&apos;src&apos;, &apos;480.png&apos;); &#125;else if(width &lt;= 800)&#123; img.attr(&apos;src&apos;, &apos;800.png&apos;); &#125;else&#123; img.attr(&apos;src&apos;, &apos;1600.png&apos;); &#125; &#125;$(window).on(&apos;resize load&apos;, makeImageResponsive);&#125;) srcset属性通过 srcset 指定给 标签所有图片源的信息。然后使用逗号分隔列出一个从小到大的图片源列表。每个图片源后可以跟w描述符或者x描述符1&lt;img src=&quot;img/480.png&quot; srcset=&quot;img/480.png 480w,img/800.png 800w, img/1600.png 1600w alt=&quot;&quot;&gt; 如果浏览器支持 srcset 则会根据屏幕宽度采用最佳的图片，否则直接下载 src 属性内的图像。 picture属性picture是html5新属性，可以放置多个source标签，以指定不同的图像文件名，进而根据不同的条件进行加载。由于现在很多浏览器对于picture这个标签还不支持，所以我们需要引用picturefill.js来解决。 1234567891011121314151617181920212223242526 &lt;div class=&quot;owl-carousel owl-theme&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad001-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad001-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad001.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad002-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad002-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad002.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad003-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad003-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad003.png&quot; alt=&quot;&quot;&gt; &lt;/picture&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 在 body 末尾引入--&gt;&lt;script src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt; 在大于800px的时候，展示ad00x-l这个large图片。在大于480px的时候，展示ad00x-m这个medium图片。否则，展示ad00x小图片。完美解决图片响应式问题，极力推荐这种方法。 打包发布当所有的代码完成之后，我们的网站就可以发布了，在发布之前我们还可以对代码进行优化： 压缩 合并 增加版本号 在线压缩:(https://javascript-minifier.com/) 工具打包： Grunt：自动化构建工具 Gulp：自动化构建工具 Webpack:静态资源打包工具 3个主流工具我就不详细一 一介绍了。这里，主要使用 gulp 来打包发布，首先来安装gulp。 第一步：安装Nodejs 在 Node.js 官网：https://nodejs.org/en/ 下载安装包 保持默认设置即可，一路Next，安装很快就结束了。 然后打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！ 第二步：安装Git 在 Git 官网：https://git-scm.com/ 下载安装包 安装完成后，桌面右键，打开 Git Bush Here，输入 git --version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ 第三步：安装Gulp(全局) 桌面右键，打开 Git Bush Here，输入npm install gulp -g 安装完成后，同样输入 gulp -v，出现版本号则说明，则说明安装成功。 第四步：作为项目的开发依赖（devDependencies）安装1$ npm install --save-dev gulp 第五步：在项目根目录下创建一个名为 gulpfile.js 的文件，并且新建一个 dist 文件夹，用于存放压缩后的文件123456789101112131415161718192021222324252627var gulp = require(&apos;gulp&apos;);var rev = require(&apos;gulp-rev&apos;);var revReplace = require(&apos;gulp-rev-replace&apos;);var useref = require(&apos;gulp-useref&apos;);var filter = require(&apos;gulp-filter&apos;);var uglify = require(&apos;gulp-uglify&apos;);var csso = require(&apos;gulp-csso&apos;);gulp.task(&apos;default&apos;, function() &#123; var jsFilter = filter(&apos;**/*.js&apos;, &#123;restore: true&#125;); var cssFilter = filter(&apos;**/*.css&apos;, &#123;restore: true&#125;); var indexHtmlFilter = filter([&apos;**/*&apos;, &apos;!**/index.html&apos;], &#123;restore: true&#125;); return gulp.src(&apos;src/index.html&apos;) .pipe(useref()) .pipe(jsFilter) .pipe(uglify()) .pipe(jsFilter.restore) .pipe(cssFilter) .pipe(csso()) .pipe(cssFilter.restore) .pipe(indexHtmlFilter) .pipe(rev()) .pipe(indexHtmlFilter.restore) .pipe(revReplace()) .pipe(gulp.dest(&apos;dist&apos;));&#125;); 第六步：安装以上需要的gulp插件：1$ npm install gulp gulp-rev gulp-rev-replace gulp-useref gulp-filter gulp-filter gulp-uglify gulp-csso --save-dev 第七步：将 htlm 中需要打包合并的文件添加注释1234567891011121314&lt;!-- build:css css/combined.css --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;js/vendor/OwlCarousel2/assets/owl.carousel.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;js/vendor/OwlCarousel2/assets/owl.theme.default.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt;&lt;!-- endbuild --&gt;&lt;!-- build:js js/combined.js --&gt;&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vendor/OwlCarousel2/owl.carousel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 第八步：执行gulp1$ gulp 执行gulp之后，你会在新建的 dist 文件夹中看到打包生成的文件，目录如下：12345678dist/├── css/│ ├──combined-3f8e363e08.css // 打包合并后的css文件│ └──combined-56ca943019.css├── img/├── js/│ └── combined-7762fa2c22.js // 打包合并后的js文件└── index.html 这时候 css, js 文件都被压缩合并成了一个文件，看起来更加轻量。如果你修改了源代码中的内容，只需再次执行gulp ，则会生成另一个心得css或js文件，版本号会更新，不会覆盖之前的文件。如上面生成新的 combined-56ca943019.css 文件，也保留之前的 combined-3f8e363e08.css。 总结本篇文章包含了响应式网站开发中常见的问题及解决方案，希望对热爱前端开发的同学有所帮助，能让你们在以后的响应式开发中少走弯路。 在线演示：http://www.dpfblog.com/responsive-lichaibao/dist/index 项目源码：https://github.com/pengfeidai/responsive-lichaibao","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://dpfblog.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://dpfblog.com/tags/CSS/"},{"name":"gulp","slug":"gulp","permalink":"http://dpfblog.com/tags/gulp/"},{"name":"响应式网站","slug":"响应式网站","permalink":"http://dpfblog.com/tags/响应式网站/"}]},{"title":"响应式理财网站","slug":"licaibao-responsive","date":"2017-07-11T14:09:46.000Z","updated":"2017-09-02T14:42:58.000Z","comments":true,"path":"2017/07/11/licaibao-responsive/","link":"","permalink":"http://dpfblog.com/2017/07/11/licaibao-responsive/","excerpt":"","text":"在线演示：http://www.dpfblog.com/responsive-lichaibao/dist/index 项目源码：https://github.com/pengfeidai/responsive-lichaibao 这是一个响应式的理财网站，运用CSS 媒体查询，响应式图片，相对长度单位等前端技术，可以适配不同的设备环境，最后用gulp打包发布。 image 技术栈 HTML：实现基本的 HTML 结构 CSS：渐进增强 or 优雅降级；利用 normalize.css 来统一页面初始样式；相对单位 rem；媒体查询；清除浮动等 JS：通过简单js代码配合轮播图插件实现轮播效果；解决了一些浏览器兼容性问题； OwlCarousel2.js：响应式轮播图插件 Gulp：自动化构建工具，使用Gulp进行自动化打包发布 收获 对常见的响应式布局方法（CSS 媒体查询、Flex 弹性布局、相对单位）有了更深的认识 掌握并使用一些常用插件（如：OwlCarousel2.js，http-server等） 学会解决IE一些兼容性问题（如：html5shiv：解决IE浏览器(IE6、IE7、IE8)不支持HTML5的问题；respond：使IE浏览器(IE6、IE7、IE8)支持媒体查询中的min-width和max-width） 熟悉了自动化构建工具 Gulp 的基本流程","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://dpfblog.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://dpfblog.com/tags/CSS/"}]}]}